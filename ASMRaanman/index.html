<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASMRaanman - Your Digital Pet</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0f;
            cursor: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
// ============================================
// ASMRaanman - Desktop Companion Screensaver
// ============================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generatePlatforms();
}
resize();
window.addEventListener('resize', resize);

// ============================================
// PLATFORM SYSTEM
// ============================================
let platforms = [];

function generatePlatforms() {
    platforms = [];
    const W = canvas.width;
    const H = canvas.height;

    // Ground
    platforms.push({ x: 0, y: H - 40, w: W, h: 40, type: 'ground' });

    // Generate platforms distributed across the screen
    const cols = Math.floor(W / 250);
    const rows = Math.floor(H / 180);

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols + 1; c++) {
            if (Math.random() < 0.55) {
                const px = c * 250 + Math.random() * 120 - 30;
                const py = H - 140 - r * 160 + Math.random() * 60;
                if (py < 50 || py > H - 80) continue;
                const pw = 60 + Math.random() * 100;
                platforms.push({
                    x: px,
                    y: py,
                    w: pw,
                    h: 12,
                    type: 'platform'
                });
            }
        }
    }

    // Ensure some high platforms exist
    for (let i = 0; i < 3; i++) {
        platforms.push({
            x: Math.random() * (W - 120) + 40,
            y: 80 + Math.random() * 120,
            w: 70 + Math.random() * 80,
            h: 12,
            type: 'platform'
        });
    }
}

function drawPlatforms(time) {
    platforms.forEach(p => {
        if (p.type === 'ground') {
            // Ground - subtle line
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, p.y);
            ctx.lineTo(canvas.width, p.y);
            ctx.stroke();
            // Tick marks
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.06)';
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x + (time * 0.005) % 40, p.y);
                ctx.lineTo(x + (time * 0.005) % 40, p.y + 5);
                ctx.stroke();
            }
        } else {
            // Floating platform
            const grd = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grd.addColorStop(0, '#1a1a30');
            grd.addColorStop(1, '#101020');
            ctx.fillStyle = grd;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Top edge glow
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.w, p.y);
            ctx.stroke();

            // Circuit dots
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            for (let i = 8; i < p.w - 8; i += 18) {
                ctx.fillRect(p.x + i, p.y + 4, 3, 3);
            }
        }
    });
}

// ============================================
// PARTICLES
// ============================================
const MAX_PARTICLES = 200;
let particles = [];

function spawnParticle(x, y, type) {
    if (particles.length >= MAX_PARTICLES) return;
    const p = { x, y, type, life: 1, decay: 0.02, vx: 0, vy: 0, size: 3 };
    if (type === 'dust') {
        p.vx = (Math.random() - 0.5) * 2;
        p.vy = -Math.random() * 1.5;
        p.size = Math.random() * 3 + 1;
        p.decay = 0.03;
        p.color = '#554433';
    } else if (type === 'glow') {
        p.vx = (Math.random() - 0.5) * 3;
        p.vy = (Math.random() - 0.5) * 3;
        p.size = Math.random() * 4 + 2;
        p.decay = 0.02;
        p.color = '#00ff88';
    } else if (type === 'star') {
        p.vx = (Math.random() - 0.5) * 8;
        p.vy = (Math.random() - 0.5) * 8;
        p.size = Math.random() * 3 + 1;
        p.decay = 0.012;
        p.color = ['#ffff00','#ff00ff','#00ffff','#ff8800','#ffffff'][Math.floor(Math.random()*5)];
    } else if (type === 'zzz') {
        p.vx = Math.random() * 0.8 + 0.3;
        p.vy = -Math.random() * 0.8 - 0.4;
        p.size = Math.random() * 8 + 10;
        p.decay = 0.006;
        p.text = 'z';
        p.color = '#4488ff';
    } else if (type === 'dollar') {
        p.vx = (Math.random() - 0.5) * 5;
        p.vy = -Math.random() * 4 - 2;
        p.size = Math.random() * 10 + 8;
        p.decay = 0.02;
        p.text = '$';
        p.color = '#00cc44';
    } else if (type === 'universe') {
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * 6 + 2;
        p.vx = Math.cos(a) * s;
        p.vy = Math.sin(a) * s;
        p.size = Math.random() * 5 + 2;
        p.decay = 0.008;
        p.color = `hsl(${Math.random()*360},100%,70%)`;
    }
    particles.push(p);
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= p.decay;
        if (p.type === 'dust') p.vy -= 0.02;
        if (p.type === 'glow') { p.vx *= 0.98; p.vy *= 0.98; }
        if (p.type === 'universe') p.vy += 0.02;
        if (p.type === 'dollar') p.vy += 0.1;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function drawParticles() {
    particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        if (p.text) {
            ctx.font = `${p.size}px "Courier New",monospace`;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, p.x, p.y);
        } else {
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = p.size * 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    });
}

// ============================================
// BACKGROUND
// ============================================
let bgStars = [];
function initBgStars() {
    bgStars = [];
    for (let i = 0; i < 100; i++) {
        bgStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 0.5,
            speed: Math.random() * 0.02 + 0.01,
            phase: Math.random() * Math.PI * 2,
        });
    }
}
initBgStars();

function drawBackground(time) {
    const grad = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height) * 0.7
    );
    grad.addColorStop(0, '#0d0d18');
    grad.addColorStop(1, '#050508');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    bgStars.forEach(s => {
        const b = 0.3 + Math.sin(time * s.speed + s.phase) * 0.35 + 0.3;
        ctx.fillStyle = `rgba(255,255,255,${b})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
    });

    // Nebula
    const nx = canvas.width * 0.7 + Math.sin(time * 0.0003) * 100;
    const ny = canvas.height * 0.3 + Math.cos(time * 0.0002) * 50;
    const ng = ctx.createRadialGradient(nx, ny, 0, nx, ny, 300);
    ng.addColorStop(0, 'rgba(0,255,136,0.03)');
    ng.addColorStop(0.5, 'rgba(100,0,255,0.015)');
    ng.addColorStop(1, 'transparent');
    ctx.fillStyle = ng;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Scanlines
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    for (let y = 0; y < canvas.height; y += 4) {
        ctx.fillRect(0, y, canvas.width, 1);
    }
}

// ============================================
// AMBIENT FLOATING TEXT
// ============================================
let ambientTexts = [];
const AMBIENT_WORDS = [
    'async','await','const','void','null','undefined','{}','()','=> ','...',
    '&&','||','===','fn()','loop','break','yield','import','export',
    '0xFF','42','NaN','Infinity','true','sudo','grep',
];
function spawnAmbientText() {
    if (ambientTexts.length > 15) return;
    ambientTexts.push({
        text: AMBIENT_WORDS[Math.floor(Math.random() * AMBIENT_WORDS.length)],
        x: Math.random() * canvas.width,
        y: canvas.height + 20,
        vy: -0.2 - Math.random() * 0.3,
        alpha: 0.05 + Math.random() * 0.03,
        size: 10 + Math.random() * 6,
    });
}
function updateAmbientTexts() {
    for (let i = ambientTexts.length - 1; i >= 0; i--) {
        ambientTexts[i].y += ambientTexts[i].vy;
        if (ambientTexts[i].y < -30) ambientTexts.splice(i, 1);
    }
}
function drawAmbientTexts() {
    ctx.save();
    ambientTexts.forEach(t => {
        ctx.globalAlpha = t.alpha;
        ctx.font = `${t.size}px "Courier New",monospace`;
        ctx.fillStyle = '#00ff88';
        ctx.fillText(t.text, t.x, t.y);
    });
    ctx.restore();
}

// ============================================
// TECH ONE-LINERS & REVELATIONS
// ============================================
const ONELINERS = [
    "Blender crashed again.\nMy 12-hour sculpt...\ngone. Like tears in rain.",
    "while(alive) { coffee++; }",
    "My code compiles.\nI am suspicious.",
    "I dream in Blueprints...\nentire node graphs\nin my sleep",
    "My therapist says I have\nunresolved promises",
    "404: motivation not found",
    "git commit -m\n'existential crisis'",
    "I benchmarked reality.\n30fps, could be better.",
    "I asked an LLM\nto write my code.\nIt wrote my resignation.",
    "Segfault in the matrix detected",
    "Is this... a simulation?\n*opens Unreal Engine*\nI could make a better one",
    "I tried to center a div once.\nStill in therapy.",
    "My Blender donut took\n47 attempts.\nWorth it.",
    "*whispers in ASMR*\n...semicolons are optional",
    "*taps keyboard softly*\nshhhh...\nthe shader is compiling",
    "Mina fraaaaames!",
    "I deploy on Fridays.\nFear me.",
    "I once wrote Python\nwithout a virtualenv.\nChaos.",
    "*adjusts tiny sunglasses*\nI see through the matrix",
    "My turtleneck contains\n99% of my power",
    "Unreal Engine:\nwhere your GPU goes\nto find religion",
    "Python is just\npseudocode that runs.\nAnd I love it.",
    "The LLM said my code\nwas 'interesting'.\nI felt judged.",
    "Blender UV unwrapping\nis my villain origin story",
    "import antigravity\n...wait that actually works\nin Python",
    "My Unreal project\nhas more Blueprints\nthan an architect's office",
    "I trained an LLM on\nmy commit messages.\nIt learned to cry.",
    "Ctrl+Z is my love language.\nBlender taught me that.",
    "*opens task manager*\nUnreal Engine: 98% RAM\nBlender: 97% RAM\nChrome: yes",
    "I asked ChatGPT to review\nmy Blueprints.\nIt said 'seek help'.",
    "Subsurface scattering\nis why I got into 3D.\nSkin is beautiful.",
    "Python one-liner?\nMore like Python one-liner\nthat spans 400 characters",
    "Nanite and Lumen\nchanged my life.\nMy electricity bill too.",
    "Every vertex\nis a decision.\nEvery face, a commitment.",
];
const CAUGHT_REVELATIONS = [
    "The universe is just\nGod's side project.\nNo unit tests.",
    "Reality runs on a\nsingle-threaded event loop.\nThat's why time feels linear.",
    "Consciousness is just recursion\nthat forgot its base case.",
    "Dark matter is\ncommented-out code\nthe universe forgot to delete.",
    "Free will is an illusion...\nbut at least the illusion\nhas good UX.",
    "The meaning of life?\nIt's in the README,\nbut nobody reads it.",
    "The universe is a\nBlender scene.\nSomeone forgot to\nsmooth-shade it.",
    "Every atom is a vertex.\nReality has a higher\npoly count than you think.",
    "The Big Bang was God\nhitting Play in Unreal Engine.\nNo optimization pass.",
    "Deja vu is a cache hit.\nYour brain already\nloaded this moment.",
    "Parallel universes are just\nGit branches nobody merged.",
    "Dreams are your brain's\nstaging environment.",
    "LLMs don't understand.\nBut neither do we.\nWe just pretend better.",
    "Gravity is CSS float.\nEverything just falls\nto the bottom.",
    "Reality is procedurally\ngenerated. God used\na seed value. It's 42.",
    "The universe compiles.\nBut nobody has seen\nthe source code.\nNot even the LLMs.",
];

// ============================================
// RAANMAN CHARACTER - matches main game look!
// Bald head, tiny sunglasses, black turtleneck,
// slight smirk, dark pants, animated legs
// ============================================
const R = {
    x: 400, y: 300,
    vx: 0, vy: 0,
    speed: 1.5, maxSpeed: 4, fleeSpeed: 9,
    facing: 1,
    state: 'idle',
    grounded: true,
    groundY: 0,
    currentPlatform: null,
    frame: 0, frameTimer: 0,
    wanderTimer: 0, wanderDir: 0,
    idleTimer: 0,
    sleepTimer: 0,
    speechBubble: null, speechTimer: 0,
    catchTimer: 0,
    panicLevel: 0,
    caughtCount: 0,
    dustTimer: 0,
    glowRadius: 0,
    revelationShown: false,
    awareness: 180,
    jumpTarget: null, // platform to jump to
    legAnim: 0,
    squash: 1, stretch: 1,
};

// Character size (drawn procedurally like the main game)
const CHAR_W = 30;
const CHAR_H = 55;

function drawRaanmanBody(x, y, squash, stretch, facing) {
    ctx.save();
    ctx.translate(x + CHAR_W/2, y + CHAR_H);
    ctx.scale(squash * facing, stretch);
    ctx.translate(-(x + CHAR_W/2), -(y + CHAR_H));

    const bx = x; // base x
    const by = y + CHAR_H; // feet y

    // Black turtleneck body
    ctx.fillStyle = '#111';
    ctx.fillRect(bx + 5, by - 30, 20, 25);

    // Turtleneck collar
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(bx + 3, by - 32, 24, 8);

    // Bald head - devastatingly smooth
    ctx.fillStyle = '#ffdbac';
    ctx.shadowColor = '#ffdbac';
    ctx.shadowBlur = 5;
    ctx.beginPath();
    ctx.arc(bx + 15, by - 38, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Tiny sunglasses
    if (R.state === 'sleep') {
        // Closed eyes when sleeping
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bx + 8, by - 39);
        ctx.lineTo(bx + 13, by - 39);
        ctx.moveTo(bx + 17, by - 39);
        ctx.lineTo(bx + 22, by - 39);
        ctx.stroke();
    } else if (R.state === 'caught') {
        // Glowing eyes when caught
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 8;
        ctx.fillRect(bx + 7, by - 41, 6, 3);
        ctx.fillRect(bx + 17, by - 41, 6, 3);
        ctx.shadowBlur = 0;
    } else {
        // Normal tiny sunglasses
        ctx.fillStyle = '#000';
        ctx.fillRect(bx + 7, by - 41, 6, 3);
        ctx.fillRect(bx + 17, by - 41, 6, 3);
        ctx.fillRect(bx + 13, by - 40, 4, 1);

        // Reflection on glasses
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(bx + 8, by - 41, 2, 1);
        ctx.fillRect(bx + 18, by - 41, 2, 1);

        // Scared wide eyes peek above glasses
        if (R.panicLevel > 0.5) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(bx + 8, by - 43, 4, 2);
            ctx.fillRect(bx + 18, by - 43, 4, 2);
            ctx.fillStyle = '#111';
            ctx.fillRect(bx + 9, by - 43, 2, 2);
            ctx.fillRect(bx + 19, by - 43, 2, 2);
        }
    }

    // Slight smirk
    if (R.state === 'caught') {
        // Open mouth in awe
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(bx + 15, by - 33, 3, 0, Math.PI * 2);
        ctx.fill();
    } else if (R.state === 'sleep') {
        // Peaceful
        ctx.strokeStyle = '#995533';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(bx + 15, by - 34, 3, 0.3, Math.PI - 0.3);
        ctx.stroke();
    } else if (R.panicLevel > 0.3) {
        // Open scared mouth
        ctx.fillStyle = '#cc4444';
        ctx.beginPath();
        ctx.ellipse(bx + 15, by - 33, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Classic smirk
        ctx.strokeStyle = '#995533';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(bx + 15, by - 33, 4, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }

    // Arms
    ctx.fillStyle = '#111';
    if (R.state === 'caught') {
        // Arms up in wonder
        ctx.fillRect(bx - 2, by - 34, 6, 3);
        ctx.fillRect(bx + 26, by - 34, 6, 3);
        ctx.fillRect(bx - 4, by - 42, 4, 10);
        ctx.fillRect(bx + 30, by - 42, 4, 10);
    } else if (R.state === 'flee') {
        // Pumping arms
        const armSwing = Math.sin(R.legAnim * 0.5) * 5;
        ctx.fillRect(bx - 1, by - 28 + armSwing, 5, 12);
        ctx.fillRect(bx + 26, by - 28 - armSwing, 5, 12);
    } else {
        // Relaxed
        ctx.fillRect(bx + 1, by - 26, 4, 14);
        ctx.fillRect(bx + 25, by - 26, 4, 14);
    }

    // Legs with walking animation
    ctx.fillStyle = '#222';
    const legOffset = R.grounded ? Math.sin(R.legAnim * 0.3) * (Math.abs(R.vx) > 1 ? 4 : 0) : 3;
    ctx.fillRect(bx + 7, by - 5 - legOffset, 6, 10 + legOffset);
    ctx.fillRect(bx + 17, by - 5 + legOffset, 6, 10 - legOffset);

    // Shoes
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(bx + 5, by + 4 - legOffset, 9, 3);
    ctx.fillRect(bx + 16, by + 4 + legOffset, 9, 3);

    ctx.restore();
}

// ============================================
// SPEECH BUBBLE - LONGER DURATION
// ============================================
function showSpeech(text, duration) {
    R.speechBubble = text;
    // Scale duration by line count for readability (min 400 frames ~6.5s)
    const lines = text.split('\n').length;
    R.speechTimer = duration || Math.max(400, lines * 180);
}

function drawSpeechBubble() {
    if (!R.speechBubble || R.speechTimer <= 0) return;

    const lines = R.speechBubble.split('\n');
    const lineHeight = 18;
    const padding = 14;
    const maxLineW = Math.max(...lines.map(l => ctx.measureText ? l.length : l.length)) * 9;
    const bubbleW = Math.min(Math.max(maxLineW + padding * 2, 140), 380);
    const bubbleH = lines.length * lineHeight + padding * 2;

    // Position above raanman, clamped to screen
    let bx = R.x + CHAR_W / 2 - bubbleW / 2;
    let by = R.y - bubbleH - 20;
    bx = Math.max(8, Math.min(canvas.width - bubbleW - 8, bx));
    if (by < 10) by = R.y + CHAR_H + 15; // Below if no room above

    // Fade in/out
    const fadeIn = Math.min(1, (R.speechTimer > 40) ? 1 : R.speechTimer / 40);
    const alpha = fadeIn;

    ctx.save();
    ctx.globalAlpha = alpha;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    roundRect(ctx, bx + 3, by + 3, bubbleW, bubbleH, 10);
    ctx.fill();

    // Bubble
    ctx.fillStyle = 'rgba(5, 5, 15, 0.92)';
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 2;
    ctx.beginPath();
    roundRect(ctx, bx, by, bubbleW, bubbleH, 10);
    ctx.fill();
    ctx.stroke();

    // Pointer
    const pointerX = Math.max(bx + 15, Math.min(bx + bubbleW - 15, R.x + CHAR_W / 2));
    const pointerBaseY = (by > R.y) ? by : by + bubbleH;
    const pointerTipY = (by > R.y) ? by - 10 : by + bubbleH + 10;
    ctx.fillStyle = 'rgba(5, 5, 15, 0.92)';
    ctx.beginPath();
    ctx.moveTo(pointerX - 8, pointerBaseY);
    ctx.lineTo(pointerX, pointerTipY);
    ctx.lineTo(pointerX + 8, pointerBaseY);
    ctx.fill();
    ctx.strokeStyle = '#00ff88';
    ctx.beginPath();
    ctx.moveTo(pointerX - 8, pointerBaseY);
    ctx.lineTo(pointerX, pointerTipY);
    ctx.lineTo(pointerX + 8, pointerBaseY);
    ctx.stroke();

    // Text
    ctx.font = '14px "Courier New",monospace';
    ctx.fillStyle = '#00ff88';
    ctx.textAlign = 'center';
    lines.forEach((line, i) => {
        ctx.fillText(line, bx + bubbleW / 2, by + padding + 14 + i * lineHeight);
    });

    ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
}

// ============================================
// CATCH MECHANIC & UNIVERSE REVEAL
// ============================================
let universeReveal = { active: false, radius: 0, targetRadius: 0, alpha: 0, text: '' };

function catchRaanman() {
    R.state = 'caught';
    R.catchTimer = 700;
    R.caughtCount++;
    R.vx = 0; R.vy = 0;
    R.revelationShown = false;

    for (let i = 0; i < 50; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H/2, 'universe');
    for (let i = 0; i < 15; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H/2, 'star');
}

function drawUniverseReveal(time) {
    if (!universeReveal.active) return;
    universeReveal.radius += (universeReveal.targetRadius - universeReveal.radius) * 0.03;
    universeReveal.alpha = Math.min(universeReveal.alpha + 0.008, 0.85);

    const cx = canvas.width / 2, cy = canvas.height / 2;
    ctx.save();

    const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, universeReveal.radius);
    rg.addColorStop(0, `rgba(20,0,50,${universeReveal.alpha})`);
    rg.addColorStop(0.5, `rgba(0,20,40,${universeReveal.alpha * 0.8})`);
    rg.addColorStop(1, 'transparent');
    ctx.fillStyle = rg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (universeReveal.radius > 50) {
        ctx.strokeStyle = `rgba(0,255,136,${universeReveal.alpha * 0.3})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(cx, cy, universeReveal.radius * (0.3 + i * 0.2),
                time * 0.001 + i, time * 0.001 + i + Math.PI * 1.5);
            ctx.stroke();
        }
    }

    if (universeReveal.radius > 200 && universeReveal.text) {
        const ta = Math.min(1, (universeReveal.radius - 200) / 100);
        ctx.globalAlpha = ta;
        ctx.font = '22px "Courier New",monospace';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 20;
        universeReveal.text.split('\n').forEach((line, i, arr) => {
            ctx.fillText(line, cx, cy - (arr.length * 14) + i * 30);
        });
    }
    ctx.restore();
}

// ============================================
// CUSTOM CURSOR
// ============================================
function drawCursor(time) {
    if (!mouse.active) return;
    ctx.save();
    const pulse = Math.sin(time * 0.005) * 3;
    ctx.strokeStyle = `rgba(0,255,136,0.5)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 12 + pulse, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = `rgba(0,255,136,0.8)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(mouse.x - 6, mouse.y); ctx.lineTo(mouse.x + 6, mouse.y);
    ctx.moveTo(mouse.x, mouse.y - 6); ctx.lineTo(mouse.x, mouse.y + 6);
    ctx.stroke();
    ctx.restore();
}

// ============================================
// MOUSE
// ============================================
let mouse = { x: -1000, y: -1000, vx: 0, vy: 0, active: false };
let lastMouseMove = 0;

document.addEventListener('mousemove', e => {
    mouse.vx = e.clientX - mouse.x;
    mouse.vy = e.clientY - mouse.y;
    mouse.x = e.clientX;
    mouse.y = e.clientY;
    mouse.active = true;
    lastMouseMove = performance.now();
});
document.addEventListener('mouseleave', () => { mouse.active = false; });
document.addEventListener('mouseenter', () => { mouse.active = true; });
document.addEventListener('click', e => {
    if (R.state === 'caught') return;
    const dx = e.clientX - (R.x + CHAR_W/2);
    const dy = e.clientY - (R.y + CHAR_H/2);
    if (Math.sqrt(dx*dx + dy*dy) < 45) {
        catchRaanman();
    } else if (R.state !== 'sleep') {
        showSpeech(ONELINERS[Math.floor(Math.random() * ONELINERS.length)]);
        R.state = 'idle';
        R.idleTimer = 180;
    }
});

// ============================================
// RAANMAN AI
// ============================================
function findPlatformBelow(x, y) {
    let best = null;
    let bestY = Infinity;
    platforms.forEach(p => {
        if (x + CHAR_W > p.x + 5 && x < p.x + p.w - 5 && p.y >= y + CHAR_H - 2 && p.y < bestY) {
            best = p;
            bestY = p.y;
        }
    });
    return best;
}

function findNearbyPlatform() {
    // Find a random platform raanman could jump to
    const candidates = platforms.filter(p => {
        if (p.type === 'ground') return false;
        const dx = (p.x + p.w/2) - (R.x + CHAR_W/2);
        const dy = (p.y) - (R.y + CHAR_H);
        const dist = Math.sqrt(dx*dx + dy*dy);
        return dist < 350 && dist > 50;
    });
    return candidates.length > 0 ? candidates[Math.floor(Math.random() * candidates.length)] : null;
}

function updateRaanman(time) {
    R.legAnim += Math.abs(R.vx) * 0.5 + (R.state === 'flee' ? 2 : 0);

    // Speech
    if (R.speechTimer > 0) R.speechTimer--;

    // Dust when running on ground
    if (R.grounded && Math.abs(R.vx) > 2) {
        R.dustTimer++;
        if (R.dustTimer % 5 === 0) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dust');
    }

    // Squash/stretch recovery
    R.squash += (1 - R.squash) * 0.15;
    R.stretch += (1 - R.stretch) * 0.15;

    // ---- CAUGHT STATE ----
    if (R.state === 'caught') {
        R.catchTimer--;
        R.glowRadius = Math.min(R.glowRadius + 2, 80);
        if (R.catchTimer < 580 && !R.revelationShown) {
            R.revelationShown = true;
            const rev = CAUGHT_REVELATIONS[Math.floor(Math.random() * CAUGHT_REVELATIONS.length)];
            showSpeech(rev, 500);
            universeReveal.active = true;
            universeReveal.radius = 0;
            universeReveal.targetRadius = Math.max(canvas.width, canvas.height);
            universeReveal.alpha = 0;
            universeReveal.text = rev;
        }
        if (R.catchTimer % 4 === 0) {
            spawnParticle(R.x + CHAR_W/2 + (Math.random()-0.5)*40,
                R.y + CHAR_H/2 + (Math.random()-0.5)*40, 'universe');
        }
        if (R.catchTimer <= 0) {
            R.state = 'idle';
            R.idleTimer = 180;
            R.glowRadius = 0;
            universeReveal.active = false;
            showSpeech("...where was I?\nOh right.\n*resumes being your\ndigital pet*");
        }
        return;
    }

    // ---- SLEEP STATE ----
    if (R.state === 'sleep') {
        R.sleepTimer--;
        if (R.sleepTimer % 50 === 0) spawnParticle(R.x + CHAR_W + 5, R.y + 10, 'zzz');
        const dx = mouse.x - R.x, dy = mouse.y - R.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if ((mouse.active && dist < R.awareness) || R.sleepTimer <= 0) {
            R.state = 'idle';
            R.idleTimer = 90;
            if (dist < R.awareness) showSpeech("*yawn* ...was I sleeping\non the job again?");
        }
        return;
    }

    // ---- MOUSE FLEE ----
    if (mouse.active) {
        const dx = mouse.x - (R.x + CHAR_W/2);
        const dy = mouse.y - (R.y + CHAR_H/2);
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Predict cursor
        const predX = mouse.x + mouse.vx * 10;
        const predY = mouse.y + mouse.vy * 10;
        const pdx = predX - (R.x + CHAR_W/2);
        const pdy = predY - (R.y + CHAR_H/2);
        const predDist = Math.sqrt(pdx*pdx + pdy*pdy);
        const effectiveDist = Math.min(dist, predDist);

        if (effectiveDist < R.awareness) {
            R.panicLevel = Math.min(1, R.panicLevel + 0.04);
            R.state = 'flee';

            // Flee direction
            const fleeX = (mouse.x + predX) / 2;
            const fleeDx = R.x - fleeX;
            const fleeLen = Math.abs(fleeDx) || 1;
            const panic = 1 + R.panicLevel * 2;
            R.vx += (fleeDx / fleeLen) * R.fleeSpeed * 0.15 * panic;

            // Jump away if close + mouse is fast
            const mouseSpd = Math.sqrt(mouse.vx*mouse.vx + mouse.vy*mouse.vy);
            if (effectiveDist < 100 && R.grounded && mouseSpd > 3) {
                R.vy = -14 - Math.random() * 4;
                R.grounded = false;
                R.squash = 1.3; R.stretch = 0.7;
                for (let i = 0; i < 5; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dollar');
            }

            // Also try jumping to higher platform to escape
            if (effectiveDist < 120 && R.grounded && Math.random() < 0.03) {
                const target = findNearbyPlatform();
                if (target && target.y < R.y) {
                    R.vy = -12 - Math.random() * 3;
                    R.grounded = false;
                    R.vx += (target.x + target.w/2 > R.x ? 3 : -3);
                }
            }

            // Scared speech
            if (effectiveDist < 60 && R.speechTimer <= 0) {
                showSpeech(["AAHH!! TOO CLOSE!","nononono not again!",
                    "I HAVE A FIREWALL!","MY PERSONAL SPACE!",
                    "CURSOR DETECTED!!","EXCEPTION THROWN!",
                    "*screams in JavaScript*"][Math.floor(Math.random()*7)], 80);
            }
        } else {
            R.panicLevel = Math.max(0, R.panicLevel - 0.01);
            if (R.state === 'flee') {
                R.state = 'wander';
                R.wanderTimer = 100 + Math.random() * 200;
            }
        }
    } else {
        R.panicLevel = Math.max(0, R.panicLevel - 0.02);
    }

    // ---- IDLE ----
    if (R.state === 'idle') {
        R.idleTimer--;
        R.vx *= 0.85;

        if (R.idleTimer <= 0) {
            const roll = Math.random();
            if (roll < 0.35) {
                R.state = 'wander';
                R.wanderTimer = 100 + Math.random() * 250;
                R.wanderDir = Math.random() > 0.5 ? 1 : -1;
            } else if (roll < 0.6) {
                // Jump to a platform
                const target = findNearbyPlatform();
                if (target && R.grounded) {
                    const jumpH = R.y + CHAR_H - target.y;
                    R.vy = -Math.min(16, Math.max(8, Math.sqrt(jumpH * 1.2) + 2));
                    R.grounded = false;
                    R.squash = 1.3; R.stretch = 0.7;
                    R.vx = ((target.x + target.w/2) - (R.x + CHAR_W/2)) * 0.04;
                    R.state = 'wander';
                    R.wanderTimer = 80;
                } else {
                    R.state = 'wander';
                    R.wanderTimer = 120;
                    R.wanderDir = Math.random() > 0.5 ? 1 : -1;
                }
            } else if (roll < 0.78) {
                // Random jump
                if (R.grounded) {
                    R.vy = -9 - Math.random() * 5;
                    R.grounded = false;
                    R.squash = 1.2; R.stretch = 0.8;
                    R.state = 'wander';
                    R.wanderTimer = 60;
                    R.wanderDir = Math.random() > 0.5 ? 1 : -1;
                }
            } else {
                R.state = 'sleep';
                R.sleepTimer = 400 + Math.random() * 500;
                showSpeech("*yawn*\ndigital pets need\ndigital naps...");
            }
        }
    }

    // ---- WANDER ----
    if (R.state === 'wander') {
        R.wanderTimer--;
        R.vx += R.wanderDir * 0.3;
        R.vx = Math.max(-R.maxSpeed, Math.min(R.maxSpeed, R.vx));
        if (R.wanderTimer <= 0) {
            R.state = 'idle';
            R.idleTimer = 60 + Math.random() * 150;
        }
    }

    // ---- PHYSICS ----
    R.vx *= (R.state === 'flee') ? 0.94 : 0.91;
    const maxSpd = R.state === 'flee' ? R.fleeSpeed * (1 + R.panicLevel) : R.maxSpeed;
    R.vx = Math.max(-maxSpd, Math.min(maxSpd, R.vx));

    // Gravity
    if (!R.grounded) {
        R.vy += 0.55;
        R.y += R.vy;
    }

    // Platform collision
    if (R.vy >= 0) {
        const plat = findPlatformBelow(R.x + 4, R.y);
        if (plat && R.y + CHAR_H >= plat.y && R.y + CHAR_H <= plat.y + 20) {
            R.y = plat.y - CHAR_H;
            R.vy = 0;
            if (!R.grounded) {
                R.squash = 0.7; R.stretch = 1.3;
                for (let i = 0; i < 4; i++) spawnParticle(R.x + CHAR_W/2 + (Math.random()-0.5)*15, R.y + CHAR_H, 'dust');
            }
            R.grounded = true;
            R.currentPlatform = plat;
        } else if (R.grounded && R.currentPlatform) {
            // Check if still on platform
            const p = R.currentPlatform;
            if (R.x + CHAR_W < p.x + 2 || R.x > p.x + p.w - 2) {
                R.grounded = false;
                R.currentPlatform = null;
            }
        }
    } else {
        R.grounded = false;
        R.currentPlatform = null;
    }

    // Fallback: don't fall below ground
    const ground = platforms.find(p => p.type === 'ground');
    if (ground && R.y + CHAR_H > ground.y) {
        R.y = ground.y - CHAR_H;
        R.vy = 0;
        if (!R.grounded) {
            R.squash = 0.7; R.stretch = 1.3;
            for (let i = 0; i < 4; i++) spawnParticle(R.x + CHAR_W/2 + (Math.random()-0.5)*15, R.y + CHAR_H, 'dust');
        }
        R.grounded = true;
        R.currentPlatform = ground;
    }

    // Move
    R.x += R.vx;
    if (Math.abs(R.vx) > 0.5) R.facing = R.vx > 0 ? 1 : -1;

    // Wrap screen
    if (R.x < -CHAR_W - 10) R.x = canvas.width + 5;
    if (R.x > canvas.width + 10) R.x = -CHAR_W - 5;

    // Animation frame
    R.frameTimer++;
    if (R.frameTimer >= (R.state === 'flee' ? 3 : 8)) {
        R.frame = (R.frame + 1) % 2;
        R.frameTimer = 0;
    }
}

// ============================================
// DRAW RAANMAN
// ============================================
function drawRaanman(time) {
    ctx.save();

    // Glow
    const baseGlow = 15 + Math.sin(time * 0.003) * 5;
    const glowSize = R.state === 'caught' ? R.glowRadius : baseGlow;
    const cx = R.x + CHAR_W/2, cy = R.y + CHAR_H/2;
    const gg = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowSize);
    if (R.state === 'caught') {
        gg.addColorStop(0, 'rgba(255,255,255,0.15)');
        gg.addColorStop(0.5, 'rgba(0,255,200,0.08)');
        gg.addColorStop(1, 'transparent');
    } else {
        gg.addColorStop(0, 'rgba(0,255,136,0.07)');
        gg.addColorStop(1, 'transparent');
    }
    ctx.fillStyle = gg;
    ctx.fillRect(cx - glowSize, cy - glowSize, glowSize * 2, glowSize * 2);

    // Shadow
    const ground = platforms.find(p => p.type === 'ground');
    if (ground) {
        const shadowY = R.currentPlatform ? R.currentPlatform.y : ground.y;
        const jumpH = shadowY - (R.y + CHAR_H);
        const shadowScale = Math.max(0.3, 1 - jumpH / 200);
        ctx.fillStyle = `rgba(0,0,0,${0.25 * shadowScale})`;
        ctx.beginPath();
        ctx.ellipse(R.x + CHAR_W/2, shadowY, CHAR_W * 0.5 * shadowScale, 3 * shadowScale, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Panic shake
    let sx = 0, sy = 0;
    if (R.panicLevel > 0.5) {
        sx = (Math.random() - 0.5) * R.panicLevel * 4;
        sy = (Math.random() - 0.5) * R.panicLevel * 2;
    }

    // Idle bob
    let bobY = 0;
    if (R.state === 'idle' && R.grounded) bobY = Math.sin(time * 0.004) * 2;

    // Draw the body
    drawRaanmanBody(R.x + sx, R.y + bobY + sy, R.squash, R.stretch, R.facing);

    // Sweat when fleeing
    if (R.state === 'flee' && R.panicLevel > 0.3 && Math.floor(time / 200) % 2 === 0) {
        ctx.fillStyle = `rgba(100,180,255,${R.panicLevel})`;
        ctx.beginPath();
        const sweatX = R.x + (R.facing === 1 ? CHAR_W + 4 : -4);
        ctx.arc(sweatX, R.y + 12 + Math.sin(time * 0.01) * 3, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// ============================================
// HUD
// ============================================
function drawHUD(time) {
    ctx.save();
    ctx.font = '11px "Courier New",monospace';
    ctx.fillStyle = `rgba(0,255,136,${R.state === 'sleep' ? 0.2 : 0.5})`;
    ctx.textAlign = 'center';
    ctx.fillText('ASMRaanman', R.x + CHAR_W/2, R.y - 8);

    ctx.textAlign = 'right';
    ctx.font = '12px "Courier New",monospace';
    ctx.fillStyle = 'rgba(0,255,136,0.25)';
    ctx.fillText(`catches: ${R.caughtCount}`, canvas.width - 15, 25);

    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,255,136,0.12)';
    ctx.font = '10px "Courier New",monospace';
    const stateText = R.state === 'flee' ? 'EVADING' :
        R.state === 'caught' ? 'ENLIGHTENED' :
        R.state === 'sleep' ? 'ZzZzZ...' :
        R.state === 'wander' ? 'exploring...' : 'vibing';

    // Pet mood indicator
    ctx.fillStyle = 'rgba(0,255,136,0.08)';
    ctx.font = '9px "Courier New",monospace';
    const mood = R.panicLevel > 0.5 ? 'PANICKED' :
        R.state === 'caught' ? 'TRANSCENDENT' :
        R.state === 'sleep' ? 'DREAMING' :
        R.caughtCount > 5 ? 'TRUSTS YOU' :
        R.caughtCount > 2 ? 'WARMING UP' : 'SHY';
    ctx.fillText(`mood: ${mood}`, 15, canvas.height - 30);
    ctx.fillText(`> ${stateText}`, 15, canvas.height - 15);

    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,255,136,0.06)';
    ctx.fillText('ASMRaanman // your digital pet // raanman.lol', canvas.width / 2, canvas.height - 10);
    ctx.restore();
}

// ============================================
// SIDE CHARACTERS: SPERRING & SYDNEY
// They pop in, chase Raanman, then disappear!
// ============================================
const sideChars = [];

const SPERRING_LINES = [
    "RAANMAN! Code review!",
    "Your PR has conflicts!",
    "The build is broken!",
    "Stand-up in 2 minutes!",
    "Did you push to main?!",
    "WHERE ARE THE TESTS?!",
];
const SYDNEY_LINES = [
    "Raanman! Deploy time!",
    "The client wants changes!",
    "Sprint retrospective NOW!",
    "Your branch is 47\ncommits behind!",
    "Raanman, JIRA is on fire!",
    "The deadline moved UP!",
];

function drawSperring(x, y, facing, frame) {
    ctx.save();
    const bx = x, by = y + 50;
    ctx.translate(x + 15, y + 50);
    ctx.scale(facing, 1);
    ctx.translate(-(x + 15), -(y + 50));

    // Hoodie body
    ctx.fillStyle = '#2244aa';
    ctx.fillRect(bx + 4, by - 28, 22, 23);

    // Hood
    ctx.fillStyle = '#1a3388';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 32, 14, Math.PI, 0);
    ctx.fill();
    ctx.fillRect(bx + 1, by - 32, 28, 6);

    // Face peeking out
    ctx.fillStyle = '#e8c89e';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 34, 9, 0, Math.PI * 2);
    ctx.fill();

    // Beady eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(bx + 10, by - 36, 3, 3);
    ctx.fillRect(bx + 17, by - 36, 3, 3);

    // Determined mouth
    ctx.strokeStyle = '#994433';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(bx + 11, by - 30);
    ctx.lineTo(bx + 19, by - 30);
    ctx.stroke();

    // Arms reaching forward (chasing!)
    ctx.fillStyle = '#2244aa';
    const armReach = Math.sin(frame * 0.4) * 6;
    ctx.fillRect(bx + 26, by - 24 + armReach, 10, 5);
    ctx.fillRect(bx + 26, by - 18 - armReach, 10, 5);

    // Legs
    ctx.fillStyle = '#333';
    const legAnim = Math.sin(frame * 0.5) * 5;
    ctx.fillRect(bx + 7, by - 5 - legAnim, 6, 10 + legAnim);
    ctx.fillRect(bx + 17, by - 5 + legAnim, 6, 10 - legAnim);

    // Shoes
    ctx.fillStyle = '#cc3333';
    ctx.fillRect(bx + 5, by + 4 - legAnim, 9, 3);
    ctx.fillRect(bx + 16, by + 4 + legAnim, 9, 3);

    ctx.restore();
}

function drawSydney(x, y, facing, frame) {
    ctx.save();
    const bx = x, by = y + 50;
    ctx.translate(x + 15, y + 50);
    ctx.scale(facing, 1);
    ctx.translate(-(x + 15), -(y + 50));

    // Purple jacket body
    ctx.fillStyle = '#7733aa';
    ctx.fillRect(bx + 4, by - 28, 22, 23);

    // Collar
    ctx.fillStyle = '#8844bb';
    ctx.fillRect(bx + 2, by - 30, 26, 5);

    // Head
    ctx.fillStyle = '#f0d0a0';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 38, 11, 0, Math.PI * 2);
    ctx.fill();

    // Hair (ponytail)
    ctx.fillStyle = '#442200';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 40, 11, Math.PI + 0.3, -0.3);
    ctx.fill();
    // Ponytail
    ctx.fillRect(bx - 2, by - 42, 6, 16);
    ctx.beginPath();
    ctx.arc(bx + 1, by - 26, 3, 0, Math.PI * 2);
    ctx.fill();

    // Big round glasses
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(bx + 11, by - 38, 5, 0, Math.PI * 2);
    ctx.arc(bx + 21, by - 38, 5, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bx + 16, by - 38);
    ctx.lineTo(bx + 16, by - 38);
    ctx.stroke();

    // Eyes behind glasses
    ctx.fillStyle = '#111';
    ctx.fillRect(bx + 10, by - 39, 2, 2);
    ctx.fillRect(bx + 20, by - 39, 2, 2);

    // Determined grin
    ctx.strokeStyle = '#aa5544';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(bx + 15, by - 32, 4, 0.2, Math.PI - 0.2);
    ctx.stroke();

    // Arms reaching
    ctx.fillStyle = '#7733aa';
    const armReach = Math.sin(frame * 0.4 + 1) * 6;
    ctx.fillRect(bx + 26, by - 22 + armReach, 10, 5);
    ctx.fillRect(bx + 26, by - 16 - armReach, 10, 5);

    // Legs
    ctx.fillStyle = '#222244';
    const legAnim = Math.sin(frame * 0.5) * 5;
    ctx.fillRect(bx + 7, by - 5 - legAnim, 6, 10 + legAnim);
    ctx.fillRect(bx + 17, by - 5 + legAnim, 6, 10 - legAnim);

    // Boots
    ctx.fillStyle = '#553388';
    ctx.fillRect(bx + 5, by + 4 - legAnim, 9, 3);
    ctx.fillRect(bx + 16, by + 4 + legAnim, 9, 3);

    ctx.restore();
}

function spawnSideCharacter() {
    if (sideChars.length > 0) return; // Only one at a time
    if (R.state === 'caught' || R.state === 'sleep') return;

    const isSperring = Math.random() > 0.5;
    const fromLeft = Math.random() > 0.5;
    const ground = platforms.find(p => p.type === 'ground');
    const groundY = ground ? ground.y - 55 : canvas.height - 95;

    const sc = {
        type: isSperring ? 'sperring' : 'sydney',
        x: fromLeft ? -40 : canvas.width + 40,
        y: groundY,
        vx: 0,
        facing: fromLeft ? 1 : -1,
        frame: 0,
        lifetime: 400 + Math.random() * 200,
        speed: 5 + Math.random() * 2,
        speechTimer: 0,
        speechText: null,
        hasSpokeEntry: false,
        hasSpokeChase: false,
        fading: false,
        alpha: 0,
    };

    sideChars.push(sc);
}

function updateSideCharacters() {
    for (let i = sideChars.length - 1; i >= 0; i--) {
        const sc = sideChars[i];
        sc.frame++;
        sc.lifetime--;

        // Fade in
        if (sc.alpha < 1 && !sc.fading) sc.alpha = Math.min(1, sc.alpha + 0.05);

        // Entry speech
        if (!sc.hasSpokeEntry && sc.alpha > 0.5) {
            sc.hasSpokeEntry = true;
            const lines = sc.type === 'sperring' ? SPERRING_LINES : SYDNEY_LINES;
            sc.speechText = lines[Math.floor(Math.random() * lines.length)];
            sc.speechTimer = 150;
        }

        // Chase Raanman!
        const dx = (R.x + CHAR_W/2) - (sc.x + 15);
        sc.facing = dx > 0 ? 1 : -1;
        sc.vx = Math.sign(dx) * sc.speed;
        sc.x += sc.vx;

        // Make Raanman react
        const dist = Math.abs(dx);
        if (dist < 200 && R.state !== 'caught') {
            R.state = 'flee';
            R.panicLevel = Math.min(1, R.panicLevel + 0.03);
            const fleeDx = R.x - sc.x;
            R.vx += Math.sign(fleeDx) * 0.8;

            if (!sc.hasSpokeChase && dist < 120) {
                sc.hasSpokeChase = true;
                const scares = [
                    "NOT " + (sc.type === 'sperring' ? 'SPERRING!' : 'SYDNEY!'),
                    "OH NO OH NO OH NO",
                    "THEY FOUND ME!",
                    "I'M ON BREAK!",
                    "MY PERSONAL SPACE!!",
                ];
                showSpeech(scares[Math.floor(Math.random() * scares.length)], 100);
                // Jump away!
                if (R.grounded) {
                    R.vy = -12;
                    R.grounded = false;
                    R.squash = 1.3; R.stretch = 0.7;
                    for (let j = 0; j < 5; j++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dollar');
                }
            }
        }

        // Speech timer
        if (sc.speechTimer > 0) sc.speechTimer--;
        if (sc.speechTimer <= 0) sc.speechText = null;

        // Start fading out
        if (sc.lifetime < 60) {
            sc.fading = true;
            sc.alpha = Math.max(0, sc.alpha - 0.02);
        }

        // Remove
        if (sc.lifetime <= 0 || sc.alpha <= 0) {
            sideChars.splice(i, 1);
        }
    }
}

function drawSideCharacters(time) {
    sideChars.forEach(sc => {
        ctx.save();
        ctx.globalAlpha = sc.alpha;

        if (sc.type === 'sperring') {
            drawSperring(sc.x, sc.y, sc.facing, sc.frame);
        } else {
            drawSydney(sc.x, sc.y, sc.facing, sc.frame);
        }

        // Name tag
        ctx.font = '10px "Courier New",monospace';
        ctx.fillStyle = sc.type === 'sperring' ? '#4466cc' : '#aa55dd';
        ctx.textAlign = 'center';
        ctx.fillText(sc.type === 'sperring' ? 'Sperring' : 'Sydney', sc.x + 15, sc.y - 5);

        // Speech
        if (sc.speechText && sc.speechTimer > 0) {
            const lines = sc.speechText.split('\n');
            const lineH = 16;
            const pad = 10;
            const maxW = Math.max(...lines.map(l => l.length)) * 8;
            const bw = Math.max(maxW + pad * 2, 100);
            const bh = lines.length * lineH + pad * 2;
            let bx = sc.x + 15 - bw / 2;
            let by = sc.y - bh - 15;
            bx = Math.max(5, Math.min(canvas.width - bw - 5, bx));
            if (by < 5) by = sc.y + 60;

            const fadeA = Math.min(1, sc.speechTimer / 30);
            ctx.globalAlpha = sc.alpha * fadeA;

            ctx.fillStyle = 'rgba(10,10,30,0.9)';
            ctx.strokeStyle = sc.type === 'sperring' ? '#4466cc' : '#aa55dd';
            ctx.lineWidth = 2;
            ctx.beginPath();
            roundRect(ctx, bx, by, bw, bh, 8);
            ctx.fill();
            ctx.stroke();

            ctx.font = '12px "Courier New",monospace';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            lines.forEach((line, li) => {
                ctx.fillText(line, bx + bw / 2, by + pad + 12 + li * lineH);
            });
        }

        ctx.restore();
    });
}

// Spawn side characters every 30-60 seconds
let sideCharSpawnTimer = 0;

// ============================================
// MAIN LOOP
// ============================================
let ambientSpawnTimer = 0;

function loop(timestamp) {
    if (performance.now() - lastMouseMove > 5000) mouse.active = false;

    drawBackground(timestamp);
    ambientSpawnTimer++;
    if (ambientSpawnTimer % 120 === 0) spawnAmbientText();
    updateAmbientTexts();
    drawAmbientTexts();

    drawPlatforms(timestamp);
    updateParticles();
    drawParticles();

    // Side characters
    sideCharSpawnTimer++;
    if (sideCharSpawnTimer > 1800 + Math.random() * 1800) { // 30-60s
        spawnSideCharacter();
        sideCharSpawnTimer = 0;
    }
    updateSideCharacters();

    updateRaanman(timestamp);
    drawRaanman(timestamp);
    drawSideCharacters(timestamp);
    drawSpeechBubble();
    drawUniverseReveal(timestamp);
    drawHUD(timestamp);
    drawCursor(timestamp);

    requestAnimationFrame(loop);
}

// Init
R.groundY = canvas.height - 40;
R.x = canvas.width / 2 - CHAR_W / 2;
R.y = R.groundY - CHAR_H;
generatePlatforms();

setTimeout(() => showSpeech("*adjusts tiny sunglasses*\n...oh, hi.\nI'm your digital pet now.\nPlease feed me commits."), 1000);

setInterval(() => {
    if (R.state !== 'caught' && R.state !== 'sleep' && R.speechTimer <= 0 && Math.random() < 0.3) {
        showSpeech(ONELINERS[Math.floor(Math.random() * ONELINERS.length)]);
    }
}, 10000);

window.addEventListener('resize', () => {
    resize();
    initBgStars();
    R.groundY = canvas.height - 40;
    if (R.y + CHAR_H > R.groundY) R.y = R.groundY - CHAR_H;
});

requestAnimationFrame(loop);
</script>
</body>
</html>
