<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASMRaanman - Your Digital Pet</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0f;
            cursor: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
// ============================================
// ASMRaanman - Desktop Companion Screensaver
// ============================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generatePlatforms();
}
// Set canvas size immediately (but don't call generatePlatforms yet - let/const not initialized)
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ============================================
// PLATFORM SYSTEM
// ============================================
let platforms = [];

function generatePlatforms() {
    platforms = [];
    const W = canvas.width;
    const H = canvas.height;

    // Ground
    platforms.push({ x: 0, y: H - 40, w: W, h: 40, type: 'ground' });

    // Generate platforms distributed across the screen
    const cols = Math.floor(W / 250);
    const rows = Math.floor(H / 180);

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols + 1; c++) {
            if (Math.random() < 0.55) {
                const px = c * 250 + Math.random() * 120 - 30;
                const py = H - 140 - r * 160 + Math.random() * 60;
                if (py < 50 || py > H - 80) continue;
                const pw = 60 + Math.random() * 100;
                platforms.push({
                    x: px,
                    y: py,
                    w: pw,
                    h: 12,
                    type: 'platform'
                });
            }
        }
    }

    // Ensure some high platforms exist
    for (let i = 0; i < 3; i++) {
        platforms.push({
            x: Math.random() * (W - 120) + 40,
            y: 80 + Math.random() * 120,
            w: 70 + Math.random() * 80,
            h: 12,
            type: 'platform'
        });
    }
}

function drawPlatforms(time) {
    platforms.forEach(p => {
        if (p.type === 'ground') {
            // Ground - subtle line
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, p.y);
            ctx.lineTo(canvas.width, p.y);
            ctx.stroke();
            // Tick marks
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.06)';
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x + (time * 0.005) % 40, p.y);
                ctx.lineTo(x + (time * 0.005) % 40, p.y + 5);
                ctx.stroke();
            }
        } else {
            // Floating platform
            const grd = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grd.addColorStop(0, '#1a1a30');
            grd.addColorStop(1, '#101020');
            ctx.fillStyle = grd;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Top edge glow
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.w, p.y);
            ctx.stroke();

            // Circuit dots
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            for (let i = 8; i < p.w - 8; i += 18) {
                ctx.fillRect(p.x + i, p.y + 4, 3, 3);
            }
        }
    });
}

// ============================================
// PARTICLES
// ============================================
const MAX_PARTICLES = 200;
let particles = [];

function spawnParticle(x, y, type) {
    if (particles.length >= MAX_PARTICLES) return;
    const p = { x, y, type, life: 1, decay: 0.02, vx: 0, vy: 0, size: 3 };
    if (type === 'dust') {
        p.vx = (Math.random() - 0.5) * 2;
        p.vy = -Math.random() * 1.5;
        p.size = Math.random() * 3 + 1;
        p.decay = 0.03;
        p.color = '#554433';
    } else if (type === 'glow') {
        p.vx = (Math.random() - 0.5) * 3;
        p.vy = (Math.random() - 0.5) * 3;
        p.size = Math.random() * 4 + 2;
        p.decay = 0.02;
        p.color = '#00ff88';
    } else if (type === 'star') {
        p.vx = (Math.random() - 0.5) * 8;
        p.vy = (Math.random() - 0.5) * 8;
        p.size = Math.random() * 3 + 1;
        p.decay = 0.012;
        p.color = ['#ffff00','#ff00ff','#00ffff','#ff8800','#ffffff'][Math.floor(Math.random()*5)];
    } else if (type === 'zzz') {
        p.vx = Math.random() * 0.8 + 0.3;
        p.vy = -Math.random() * 0.8 - 0.4;
        p.size = Math.random() * 8 + 10;
        p.decay = 0.006;
        p.text = 'z';
        p.color = '#4488ff';
    } else if (type === 'dollar') {
        p.vx = (Math.random() - 0.5) * 5;
        p.vy = -Math.random() * 4 - 2;
        p.size = Math.random() * 10 + 8;
        p.decay = 0.02;
        p.text = '$';
        p.color = '#00cc44';
    } else if (type === 'universe') {
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * 6 + 2;
        p.vx = Math.cos(a) * s;
        p.vy = Math.sin(a) * s;
        p.size = Math.random() * 5 + 2;
        p.decay = 0.008;
        p.color = `hsl(${Math.random()*360},100%,70%)`;
    }
    particles.push(p);
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= p.decay;
        if (p.type === 'dust') p.vy -= 0.02;
        if (p.type === 'glow') { p.vx *= 0.98; p.vy *= 0.98; }
        if (p.type === 'universe') p.vy += 0.02;
        if (p.type === 'dollar') p.vy += 0.1;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function drawParticles() {
    particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        if (p.text) {
            ctx.font = `${p.size}px "Courier New",monospace`;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, p.x, p.y);
        } else {
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = p.size * 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    });
}

// ============================================
// BACKGROUND
// ============================================
let bgStars = [];
function initBgStars() {
    bgStars = [];
    for (let i = 0; i < 100; i++) {
        bgStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 0.5,
            speed: Math.random() * 0.02 + 0.01,
            phase: Math.random() * Math.PI * 2,
        });
    }
}
initBgStars();

function drawBackground(time) {
    const grad = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height) * 0.7
    );
    grad.addColorStop(0, '#0d0d18');
    grad.addColorStop(1, '#050508');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    bgStars.forEach(s => {
        const b = 0.3 + Math.sin(time * s.speed + s.phase) * 0.35 + 0.3;
        ctx.fillStyle = `rgba(255,255,255,${b})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
    });

    // Nebula
    const nx = canvas.width * 0.7 + Math.sin(time * 0.0003) * 100;
    const ny = canvas.height * 0.3 + Math.cos(time * 0.0002) * 50;
    const ng = ctx.createRadialGradient(nx, ny, 0, nx, ny, 300);
    ng.addColorStop(0, 'rgba(0,255,136,0.03)');
    ng.addColorStop(0.5, 'rgba(100,0,255,0.015)');
    ng.addColorStop(1, 'transparent');
    ctx.fillStyle = ng;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Scanlines
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    for (let y = 0; y < canvas.height; y += 4) {
        ctx.fillRect(0, y, canvas.width, 1);
    }
}

// ============================================
// AMBIENT FLOATING TEXT
// ============================================
let ambientTexts = [];
const AMBIENT_WORDS = [
    'async','await','const','void','null','undefined','{}','()','=> ','...',
    '&&','||','===','fn()','loop','break','yield','import','export',
    '0xFF','42','NaN','Infinity','true','sudo','grep',
];
function spawnAmbientText() {
    if (ambientTexts.length > 15) return;
    ambientTexts.push({
        text: AMBIENT_WORDS[Math.floor(Math.random() * AMBIENT_WORDS.length)],
        x: Math.random() * canvas.width,
        y: canvas.height + 20,
        vy: -0.2 - Math.random() * 0.3,
        alpha: 0.05 + Math.random() * 0.03,
        size: 10 + Math.random() * 6,
    });
}
function updateAmbientTexts() {
    for (let i = ambientTexts.length - 1; i >= 0; i--) {
        ambientTexts[i].y += ambientTexts[i].vy;
        if (ambientTexts[i].y < -30) ambientTexts.splice(i, 1);
    }
}
function drawAmbientTexts() {
    ctx.save();
    ambientTexts.forEach(t => {
        ctx.globalAlpha = t.alpha;
        ctx.font = `${t.size}px "Courier New",monospace`;
        ctx.fillStyle = '#00ff88';
        ctx.fillText(t.text, t.x, t.y);
    });
    ctx.restore();
}

// ============================================
// TECH ONE-LINERS & REVELATIONS
// ============================================
const ONELINERS = [
    "Blender crashed again.\nMy 12-hour sculpt...\ngone. Like tears in rain.",
    "while(alive) { coffee++; }",
    "My code compiles.\nI am suspicious.",
    "I dream in Blueprints...\nentire node graphs\nin my sleep",
    "My therapist says I have\nunresolved promises",
    "404: motivation not found",
    "git commit -m\n'existential crisis'",
    "I benchmarked reality.\n30fps, could be better.",
    "I asked an LLM\nto write my code.\nIt wrote my resignation.",
    "Segfault in the matrix detected",
    "Is this... a simulation?\n*opens Unreal Engine*\nI could make a better one",
    "I tried to center a div once.\nStill in therapy.",
    "My Blender donut took\n47 attempts.\nWorth it.",
    "*whispers in ASMR*\n...semicolons are optional",
    "*taps keyboard softly*\nshhhh...\nthe shader is compiling",
    "Mina fraaaaames!",
    "I deploy on Fridays.\nFear me.",
    "I once wrote Python\nwithout a virtualenv.\nChaos.",
    "*adjusts tiny sunglasses*\nI see through the matrix",
    "My turtleneck contains\n99% of my power",
    "Unreal Engine:\nwhere your GPU goes\nto find religion",
    "Python is just\npseudocode that runs.\nAnd I love it.",
    "The LLM said my code\nwas 'interesting'.\nI felt judged.",
    "Blender UV unwrapping\nis my villain origin story",
    "import antigravity\n...wait that actually works\nin Python",
    "My Unreal project\nhas more Blueprints\nthan an architect's office",
    "I trained an LLM on\nmy commit messages.\nIt learned to cry.",
    "Ctrl+Z is my love language.\nBlender taught me that.",
    "*opens task manager*\nUnreal Engine: 98% RAM\nBlender: 97% RAM\nChrome: yes",
    "I asked ChatGPT to review\nmy Blueprints.\nIt said 'seek help'.",
    "Subsurface scattering\nis why I got into 3D.\nSkin is beautiful.",
    "Python one-liner?\nMore like Python one-liner\nthat spans 400 characters",
    "Nanite and Lumen\nchanged my life.\nMy electricity bill too.",
    "Every vertex\nis a decision.\nEvery face, a commitment.",
];
const CAUGHT_REVELATIONS = [
    "The universe is just\nGod's side project.\nNo unit tests.",
    "Reality runs on a\nsingle-threaded event loop.\nThat's why time feels linear.",
    "Consciousness is just recursion\nthat forgot its base case.",
    "Dark matter is\ncommented-out code\nthe universe forgot to delete.",
    "Free will is an illusion...\nbut at least the illusion\nhas good UX.",
    "The meaning of life?\nIt's in the README,\nbut nobody reads it.",
    "The universe is a\nBlender scene.\nSomeone forgot to\nsmooth-shade it.",
    "Every atom is a vertex.\nReality has a higher\npoly count than you think.",
    "The Big Bang was God\nhitting Play in Unreal Engine.\nNo optimization pass.",
    "Deja vu is a cache hit.\nYour brain already\nloaded this moment.",
    "Parallel universes are just\nGit branches nobody merged.",
    "Dreams are your brain's\nstaging environment.",
    "LLMs don't understand.\nBut neither do we.\nWe just pretend better.",
    "Gravity is CSS float.\nEverything just falls\nto the bottom.",
    "Reality is procedurally\ngenerated. God used\na seed value. It's 42.",
    "The universe compiles.\nBut nobody has seen\nthe source code.\nNot even the LLMs.",
];

// ============================================
// SECRET BUILD SYSTEM
// Raanman finds materials scattered on screen,
// picks them up, carries them to a build site,
// and assembles blueprints block by block.
// Push your cursor into it to destroy it!
// ============================================

// --- BLUEPRINTS: each is a grid of blocks Raanman builds ---
// Blocks are [col, row, color, label] - row 0 = ground level, builds up
const BLUEPRINTS = [
    {
        name: 'a rocket ship',
        icon: 'ðŸš€',
        buildLines: ["*placing fuel tanks*","Thrust-to-weight ratio\ncalculations...", "Elon wishes he had\nthis design", "T-minus... a lot"],
        blocks: [
            [0,0,'#555',''], [2,0,'#555',''],                   // base legs
            [1,0,'#3a4a5a',''], [1,1,'#3a4a5a',''],             // body
            [0,1,'#3a4a5a',''], [2,1,'#3a4a5a',''],             // body
            [0,2,'#445566','fn'], [1,2,'#445566',''], [2,2,'#445566','fn'], // mid
            [1,3,'#556677',''], [0,3,'#556677',''], [2,3,'#556677',''],     // upper
            [1,4,'#667788','01'], [0,4,'#556677',''], [2,4,'#556677',''],   // top
            [1,5,'#ff4422',''],                                 // nose cone
        ],
    },
    {
        name: 'a house',
        icon: 'ðŸ ',
        buildLines: ["*laying foundation*","Load-bearing walls\nare important", "This will pass\ncode review... right?", "Open floor plan!"],
        blocks: [
            [0,0,'#664422',''], [1,0,'#664422',''], [2,0,'#664422',''], [3,0,'#664422',''],  // floor
            [0,1,'#775533',''], [3,1,'#775533',''],              // walls
            [0,2,'#775533','{}'], [3,2,'#775533','{}'],          // walls
            [0,3,'#886644',''], [1,3,'#886644',''], [2,3,'#886644',''], [3,3,'#886644',''],  // ceiling
            [1,1,'#4488cc',''],                                  // window
            [2,1,'#553311',''],                                  // door
            [1,4,'#aa3322',''], [2,4,'#aa3322',''],              // roof
            [1.5,5,'#cc4433',''],                                // chimney
        ],
    },
    {
        name: 'a robot',
        icon: 'ðŸ¤–',
        buildLines: ["*wiring neural nets*","import robot_brain","This one will\npass the Turing test", "BEEP BOOP\nin progress..."],
        blocks: [
            [0,0,'#444',''], [2,0,'#444',''],                    // feet
            [0,1,'#555','fn'], [2,1,'#555','fn'],                // legs
            [0,2,'#3a5a7a',''], [1,2,'#3a5a7a','01'], [2,2,'#3a5a7a',''],  // body
            [0,3,'#3a5a7a','{}'], [1,3,'#4a6a8a',''], [2,3,'#3a5a7a','{}'],// chest
            [-0.5,3,'#555',''], [2.5,3,'#555',''],               // arms
            [0,4,'#6a8aaa',''], [1,4,'#6a8aaa',''], [2,4,'#6a8aaa',''],    // head
            [0.5,5,'#ff3333',''], [1.5,5,'#ff3333',''],          // eyes/antenna
        ],
    },
    {
        name: 'a Blender donut',
        icon: 'ðŸ©',
        buildLines: ["*subdivide... subdivide...*","The topology must be\nperfect...","Still on the donut\ntutorial...", "47th attempt.\nThis time for sure."],
        blocks: [
            [1,0,'#cc8844',''], [2,0,'#cc8844',''],              // bottom
            [0,1,'#dd9955',''], [3,1,'#dd9955',''],              // sides
            [0,2,'#dd9955',''], [3,2,'#dd9955',''],              // sides
            [1,2,'#ffaacc',''], [2,2,'#ffaacc',''],              // icing
            [0,3,'#ffbbdd',''], [3,3,'#ffbbdd',''],              // icing top
            [1,3,'#ffccee',''], [2,3,'#ffccee',''],              // icing drip
        ],
    },
    {
        name: 'an Unreal level',
        icon: 'ðŸŽ®',
        buildLines: ["*placing BSP brushes*","Nanite can handle this\n...right?", "Need more\npoint lights...", "This runs at 4fps.\nShip it."],
        blocks: [
            [0,0,'#2a4a2a',''], [1,0,'#2a4a2a',''], [2,0,'#2a4a2a',''], [3,0,'#2a4a2a',''], [4,0,'#2a4a2a',''], // ground
            [0,1,'#3a3a4a','{}'], [4,1,'#3a3a4a','{}'],          // pillars
            [0,2,'#3a3a4a',''], [4,2,'#3a3a4a',''],              // pillars
            [0,3,'#4a4a5a',''], [1,3,'#4a4a5a',''], [2,3,'#4a4a5a','fn'], [3,3,'#4a4a5a',''], [4,3,'#4a4a5a',''], // roof
            [2,1,'#5577aa','01'],                                 // pickup
            [2,4,'#ffaa22',''],                                   // light
        ],
    },
    {
        name: 'a neural network',
        icon: 'ðŸ§ ',
        buildLines: ["Layer 1... layer 2...","The loss function is\nmy emotional state.", "Adjusting weights\nnervously...", "Training epoch 47..."],
        blocks: [
            [1,0,'#4a2a6a','01'], [3,0,'#4a2a6a','01'],          // input nodes
            [0,1,'#5a3a7a','fn'], [2,1,'#5a3a7a','fn'], [4,1,'#5a3a7a','fn'], // hidden layer
            [1,2,'#6a4a8a','{}'], [3,2,'#6a4a8a','{}'],          // hidden 2
            [0,3,'#7a5a9a',''], [2,3,'#7a5a9a',''], [4,3,'#7a5a9a',''],    // hidden 3
            [2,4,'#ff6644','01'],                                 // output
        ],
    },
    {
        name: 'his magnum opus',
        icon: 'âœ¨',
        buildLines: ["This is THE ONE.","Years of experience\nled to this moment.", "*places block with\nsurgical precision*", "The world\nis not ready."],
        blocks: [
            [0,0,'#444',''], [1,0,'#444',''], [2,0,'#444',''], [3,0,'#444',''], [4,0,'#444',''],   // base
            [0,1,'#555','{}'], [4,1,'#555','{}'],                  // pillars
            [0,2,'#555',''], [4,2,'#555',''],                      // pillars
            [0,3,'#666','fn'], [1,3,'#666',''], [2,3,'#666','01'], [3,3,'#666',''], [4,3,'#666','fn'], // mid
            [1,4,'#777',''], [2,4,'#888',''], [3,4,'#777',''],    // narrow
            [2,5,'#aaa',''],                                       // tip
            [2,6,'#ffcc00',''],                                    // golden crown
        ],
    },
];

const BUILD_DESTROY_REACTIONS = [
    "NO!! My {project}!!",
    "*stares in horror*\nThat took me\nFOREVER...",
    "WHY WOULD YOU\nDO THAT?!",
    "I was ALMOST done!\n...almost.",
    "Do you know how many\nvertices that was?!",
    "*quietly sobs\nin Blender*",
    "That was going to be\nmy portfolio piece...",
    "The commit was\nSO CLOSE...",
    "I'm adding you to\nmy .gitignore",
    "My {project}...\n*whispers*\n...it's gone.",
    "Fine. I'll just\nmake another one.\n*internally screaming*",
    "That was 12 hours\nof work.\n12. HOURS.",
];

// --- BUILD STATE ---
const buildBlocks = [];          // placed blocks in the world
const scatteredMaterials = [];   // materials scattered around screen
const MAX_SCATTERED = 8;

let currentBlueprint = null;
let buildSiteX = 0;             // where we're building
let buildStepIndex = 0;         // which block in the blueprint we're on
let buildCooldown = 0;
let lastBlockDestroyedTime = 0;
let destroyReactionCooldown = 0;
const BLOCK_SIZE = 14;          // base unit for grid

function getGroundY() {
    const ground = platforms.find(p => p.type === 'ground');
    return ground ? ground.y : canvas.height - 40;
}

// Scatter materials around the screen for Raanman to find
function scatterMaterials() {
    while (scatteredMaterials.length < MAX_SCATTERED) {
        const groundY = getGroundY();
        // Place on platforms or on the ground
        const plats = platforms.filter(p => p.type !== 'ground' && p.w > 30);
        let mx, my;
        if (plats.length > 0 && Math.random() < 0.5) {
            const p = plats[Math.floor(Math.random() * plats.length)];
            mx = p.x + 10 + Math.random() * (p.w - 20);
            my = p.y - 12;
        } else {
            mx = 40 + Math.random() * (canvas.width - 80);
            my = groundY - 12;
        }
        scatteredMaterials.push({
            x: mx, y: my,
            w: 10 + Math.random() * 8,
            h: 8 + Math.random() * 6,
            color: ['#3a4a5a','#4a3a5a','#5a4a3a','#3a5a4a','#555','#4a4a5a','#5a3a3a'][Math.floor(Math.random()*7)],
            label: ['','','01','fn','{}','',''][Math.floor(Math.random()*7)],
            bobPhase: Math.random() * Math.PI * 2,
            alpha: 0,
            sparkle: Math.random() * 100,
        });
    }
}

function startBuildProject() {
    const idx = Math.floor(Math.random() * BLUEPRINTS.length);
    currentBlueprint = BLUEPRINTS[idx];
    buildStepIndex = 0;

    // Pick a build site: somewhere on the ground, not too close to edges
    const groundY = getGroundY();
    buildSiteX = 100 + Math.random() * (canvas.width - 200);

    // Clear old placed blocks
    buildBlocks.length = 0;

    // Scatter fresh materials
    scatterMaterials();
}

function findNearestMaterial() {
    let best = null, bestDist = Infinity;
    scatteredMaterials.forEach(m => {
        const dx = m.x - R.x;
        const dy = m.y - R.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < bestDist) { bestDist = d; best = m; }
    });
    return best;
}

function placeNextBuildBlock() {
    if (!currentBlueprint || buildStepIndex >= currentBlueprint.blocks.length) return false;

    const bp = currentBlueprint.blocks[buildStepIndex];
    const groundY = getGroundY();
    const col = bp[0], row = bp[1], color = bp[2], label = bp[3];

    const block = {
        x: buildSiteX + col * (BLOCK_SIZE + 1),
        y: groundY - (row + 1) * (BLOCK_SIZE - 2),
        w: BLOCK_SIZE,
        h: BLOCK_SIZE - 2,
        color: color,
        label: label,
        vx: 0, vy: 0,
        rotation: 0,
        vr: 0,
        loose: false,
        alpha: 0,
        glow: 1,
    };

    buildBlocks.push(block);
    buildStepIndex++;

    for (let i = 0; i < 4; i++) spawnParticle(block.x + block.w/2, block.y + block.h, 'dust');
    spawnParticle(block.x + block.w/2, block.y, 'glow');

    return buildStepIndex < currentBlueprint.blocks.length;
}

function updateBuildBlocks() {
    const groundY = getGroundY();

    // Update scattered materials
    scatteredMaterials.forEach(m => {
        m.alpha = Math.min(1, m.alpha + 0.02);
        m.sparkle++;
    });

    // Update placed blocks
    for (let i = buildBlocks.length - 1; i >= 0; i--) {
        const b = buildBlocks[i];
        b.alpha = Math.min(1, b.alpha + 0.05);
        b.glow = Math.max(0, b.glow - 0.015);

        // Mouse cursor pushes blocks!
        if (mouse.active) {
            const bcx = b.x + b.w / 2;
            const bcy = b.y + b.h / 2;
            const dx = bcx - mouse.x;
            const dy = bcy - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const mouseSpeed = Math.sqrt(mouse.vx * mouse.vx + mouse.vy * mouse.vy);

            if (dist < 45 && mouseSpeed > 2) {
                const force = (1 - dist / 45) * mouseSpeed * 0.35;
                b.vx += (dx / (dist || 1)) * force;
                b.vy += (dy / (dist || 1)) * force * 0.5 - 1.5;
                b.vr += (Math.random() - 0.5) * force * 0.12;
                if (!b.loose) {
                    b.loose = true;
                    lastBlockDestroyedTime = performance.now();
                    spawnParticle(bcx, bcy, 'star');
                    spawnParticle(bcx, bcy, 'star');
                }
            }
        }

        // Physics for loose blocks
        if (b.loose) {
            b.vy += 0.45;
            b.x += b.vx; b.y += b.vy;
            b.rotation += b.vr;
            b.vx *= 0.97; b.vr *= 0.96;

            // Loose blocks push other loose blocks
            for (let j = 0; j < buildBlocks.length; j++) {
                if (j === i) continue;
                const o = buildBlocks[j];
                const odx = (o.x + o.w/2) - (b.x + b.w/2);
                const ody = (o.y + o.h/2) - (b.y + b.h/2);
                const od = Math.sqrt(odx*odx + ody*ody);
                if (od < BLOCK_SIZE && (Math.abs(b.vx) > 1 || Math.abs(b.vy) > 1)) {
                    if (!o.loose) {
                        o.loose = true;
                        lastBlockDestroyedTime = performance.now();
                    }
                    o.vx += (odx / (od||1)) * 1.5;
                    o.vy += (ody / (od||1)) * 0.8 - 1;
                    o.vr += (Math.random() - 0.5) * 0.15;
                }
            }

            if (b.y + b.h > groundY) {
                b.y = groundY - b.h;
                b.vy *= -0.25;
                b.vr *= 0.4;
                if (Math.abs(b.vy) < 0.8) { b.vy = 0; b.vx *= 0.85; b.vr *= 0.7; }
            }

            if (Math.abs(b.vx) < 0.05 && Math.abs(b.vy) < 0.05 && b.y + b.h >= groundY - 2) {
                b.alpha -= 0.004;
            }

            if (b.x < -80 || b.x > canvas.width + 80 || b.y > canvas.height + 80) b.alpha = 0;
            if (b.alpha <= 0) { buildBlocks.splice(i, 1); }
        }
    }

    // React to destruction
    if (destroyReactionCooldown > 0) destroyReactionCooldown--;
    const looseCount = buildBlocks.filter(b => b.loose).length;
    if (looseCount >= 2 && performance.now() - lastBlockDestroyedTime < 300 && destroyReactionCooldown <= 0
        && R.state !== 'caught' && R.speechTimer <= 0) {
        let reaction = BUILD_DESTROY_REACTIONS[Math.floor(Math.random() * BUILD_DESTROY_REACTIONS.length)];
        if (currentBlueprint) reaction = reaction.replace('{project}', currentBlueprint.name);
        showSpeech(reaction, 280);
        destroyReactionCooldown = 400;

        // If most is destroyed, give up
        const placed = buildBlocks.filter(b => !b.loose).length;
        if (placed <= 2 && currentBlueprint) {
            currentBlueprint = null;
            buildCooldown = 800;
            R.state = 'idle';
            R.idleTimer = 200;
        }
    }
}

function drawScatteredMaterials(time) {
    scatteredMaterials.forEach(m => {
        ctx.save();
        ctx.globalAlpha = m.alpha * 0.8;
        const bob = Math.sin(time * 0.003 + m.bobPhase) * 2;

        // Block
        ctx.fillStyle = m.color;
        ctx.fillRect(m.x, m.y + bob, m.w, m.h);
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(m.x, m.y + bob, m.w, 2);

        // Label
        if (m.label) {
            ctx.font = '6px "Courier New",monospace';
            ctx.fillStyle = 'rgba(0,255,136,0.5)';
            ctx.textAlign = 'center';
            ctx.fillText(m.label, m.x + m.w/2, m.y + bob + m.h/2 + 2);
            ctx.textAlign = 'left';
        }

        // Sparkle
        if (Math.floor(m.sparkle / 40) % 2 === 0) {
            ctx.fillStyle = `rgba(0,255,136,${0.2 + Math.sin(m.sparkle * 0.1) * 0.15})`;
            ctx.beginPath();
            ctx.arc(m.x + m.w/2, m.y + bob - 4, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    });
}

function drawBuildBlocks(time) {
    // Draw build site marker if building
    if (currentBlueprint && buildBlocks.length > 0) {
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        const groundY = getGroundY();
        const bpWidth = (Math.max(...currentBlueprint.blocks.map(b => b[0])) + 1) * (BLOCK_SIZE + 1) + 10;
        const bpHeight = (Math.max(...currentBlueprint.blocks.map(b => b[1])) + 2) * (BLOCK_SIZE - 2);
        ctx.strokeRect(buildSiteX - 5, groundY - bpHeight, bpWidth, bpHeight);
        ctx.setLineDash([]);

        // Blueprint name
        ctx.globalAlpha = 0.12;
        ctx.font = '9px "Courier New",monospace';
        ctx.fillStyle = '#00ff88';
        ctx.textAlign = 'center';
        ctx.fillText(`building: ${currentBlueprint.name}`, buildSiteX + bpWidth/2, groundY - bpHeight - 6);
        ctx.restore();
    }

    // Draw blocks
    buildBlocks.forEach(b => {
        ctx.save();
        ctx.globalAlpha = b.alpha;

        if (b.rotation !== 0) {
            ctx.translate(b.x + b.w/2, b.y + b.h/2);
            ctx.rotate(b.rotation);
            ctx.translate(-(b.x + b.w/2), -(b.y + b.h/2));
        }

        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(b.x, b.y, b.w, 2);
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(b.x, b.y + b.h - 2, b.w, 2);

        if (b.glow > 0) {
            ctx.strokeStyle = `rgba(0,255,136,${b.glow * 0.5})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(b.x - 1, b.y - 1, b.w + 2, b.h + 2);
        }
        if (b.label) {
            ctx.font = '7px "Courier New",monospace';
            ctx.fillStyle = 'rgba(0,255,136,0.45)';
            ctx.textAlign = 'center';
            ctx.fillText(b.label, b.x + b.w/2, b.y + b.h/2 + 3);
            ctx.textAlign = 'left';
        }

        ctx.restore();
    });

    // Carried block
    if (R.carrying) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        const cx = R.x + CHAR_W/2 - 5;
        const cy = R.y - 8;
        ctx.fillStyle = R.carrying.color;
        ctx.fillRect(cx, cy, 10, 8);
        ctx.fillStyle = 'rgba(0,255,136,0.3)';
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 1;
        ctx.strokeRect(cx - 1, cy - 1, 12, 10);
        ctx.restore();
    }
}

// ============================================
// RAANMAN CHARACTER - matches main game look!
// Bald head, tiny sunglasses, black turtleneck,
// slight smirk, dark pants, animated legs
// ============================================
const R = {
    x: 400, y: 300,
    vx: 0, vy: 0,
    speed: 1.5, maxSpeed: 4, fleeSpeed: 9,
    facing: 1,
    state: 'idle',
    grounded: true,
    groundY: 0,
    currentPlatform: null,
    frame: 0, frameTimer: 0,
    wanderTimer: 0, wanderDir: 0,
    idleTimer: 0,
    sleepTimer: 0,
    speechBubble: null, speechTimer: 0,
    catchTimer: 0,
    panicLevel: 0,
    caughtCount: 0,
    dustTimer: 0,
    glowRadius: 0,
    revelationShown: false,
    awareness: 180,
    jumpTarget: null, // platform to jump to
    legAnim: 0,
    squash: 1, stretch: 1,
    buildTimer: 0,
    buildPlaceTimer: 0,
    carrying: null,         // material being carried
    gatherTarget: null,     // material to pick up
};

// Character size (drawn procedurally like the main game)
const CHAR_W = 30;
const CHAR_H = 55;

function drawRaanmanBody(x, y, squash, stretch, facing) {
    ctx.save();
    ctx.translate(x + CHAR_W/2, y + CHAR_H);
    ctx.scale(squash * facing, stretch);
    ctx.translate(-(x + CHAR_W/2), -(y + CHAR_H));

    const bx = x; // base x
    const by = y + CHAR_H; // feet y

    // Black turtleneck body
    ctx.fillStyle = '#111';
    ctx.fillRect(bx + 5, by - 30, 20, 25);

    // Turtleneck collar
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(bx + 3, by - 32, 24, 8);

    // Bald head - devastatingly smooth
    ctx.fillStyle = '#ffdbac';
    ctx.shadowColor = '#ffdbac';
    ctx.shadowBlur = 5;
    ctx.beginPath();
    ctx.arc(bx + 15, by - 38, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Tiny sunglasses
    if (R.state === 'sleep') {
        // Closed eyes when sleeping
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bx + 8, by - 39);
        ctx.lineTo(bx + 13, by - 39);
        ctx.moveTo(bx + 17, by - 39);
        ctx.lineTo(bx + 22, by - 39);
        ctx.stroke();
    } else if (R.state === 'caught') {
        // Glowing eyes when caught
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 8;
        ctx.fillRect(bx + 7, by - 41, 6, 3);
        ctx.fillRect(bx + 17, by - 41, 6, 3);
        ctx.shadowBlur = 0;
    } else {
        // Normal tiny sunglasses
        ctx.fillStyle = '#000';
        ctx.fillRect(bx + 7, by - 41, 6, 3);
        ctx.fillRect(bx + 17, by - 41, 6, 3);
        ctx.fillRect(bx + 13, by - 40, 4, 1);

        // Reflection on glasses
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(bx + 8, by - 41, 2, 1);
        ctx.fillRect(bx + 18, by - 41, 2, 1);

        // Scared wide eyes peek above glasses
        if (R.panicLevel > 0.5) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(bx + 8, by - 43, 4, 2);
            ctx.fillRect(bx + 18, by - 43, 4, 2);
            ctx.fillStyle = '#111';
            ctx.fillRect(bx + 9, by - 43, 2, 2);
            ctx.fillRect(bx + 19, by - 43, 2, 2);
        }
    }

    // Slight smirk
    if (R.state === 'caught') {
        // Open mouth in awe
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(bx + 15, by - 33, 3, 0, Math.PI * 2);
        ctx.fill();
    } else if (R.state === 'sleep') {
        // Peaceful
        ctx.strokeStyle = '#995533';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(bx + 15, by - 34, 3, 0.3, Math.PI - 0.3);
        ctx.stroke();
    } else if (R.panicLevel > 0.3) {
        // Open scared mouth
        ctx.fillStyle = '#cc4444';
        ctx.beginPath();
        ctx.ellipse(bx + 15, by - 33, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Classic smirk
        ctx.strokeStyle = '#995533';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(bx + 15, by - 33, 4, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }

    // Arms
    ctx.fillStyle = '#111';
    if (R.state === 'caught') {
        // Arms up in wonder
        ctx.fillRect(bx - 2, by - 34, 6, 3);
        ctx.fillRect(bx + 26, by - 34, 6, 3);
        ctx.fillRect(bx - 4, by - 42, 4, 10);
        ctx.fillRect(bx + 30, by - 42, 4, 10);
    } else if (R.state === 'flee') {
        // Pumping arms
        const armSwing = Math.sin(R.legAnim * 0.5) * 5;
        ctx.fillRect(bx - 1, by - 28 + armSwing, 5, 12);
        ctx.fillRect(bx + 26, by - 28 - armSwing, 5, 12);
    } else {
        // Relaxed
        ctx.fillRect(bx + 1, by - 26, 4, 14);
        ctx.fillRect(bx + 25, by - 26, 4, 14);
    }

    // Legs with walking animation
    ctx.fillStyle = '#222';
    const legOffset = R.grounded ? Math.sin(R.legAnim * 0.3) * (Math.abs(R.vx) > 1 ? 4 : 0) : 3;
    ctx.fillRect(bx + 7, by - 5 - legOffset, 6, 10 + legOffset);
    ctx.fillRect(bx + 17, by - 5 + legOffset, 6, 10 - legOffset);

    // Shoes
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(bx + 5, by + 4 - legOffset, 9, 3);
    ctx.fillRect(bx + 16, by + 4 + legOffset, 9, 3);

    ctx.restore();
}

// ============================================
// SPEECH BUBBLE - LONGER DURATION
// ============================================
function showSpeech(text, duration) {
    R.speechBubble = text;
    // Scale duration by line count for readability (min 400 frames ~6.5s)
    const lines = text.split('\n').length;
    R.speechTimer = duration || Math.max(400, lines * 180);
}

function drawSpeechBubble() {
    if (!R.speechBubble || R.speechTimer <= 0) return;

    const lines = R.speechBubble.split('\n');
    const lineHeight = 18;
    const padding = 14;
    const maxLineW = Math.max(...lines.map(l => ctx.measureText ? l.length : l.length)) * 9;
    const bubbleW = Math.min(Math.max(maxLineW + padding * 2, 140), 380);
    const bubbleH = lines.length * lineHeight + padding * 2;

    // Position above raanman, clamped to screen
    let bx = R.x + CHAR_W / 2 - bubbleW / 2;
    let by = R.y - bubbleH - 20;
    bx = Math.max(8, Math.min(canvas.width - bubbleW - 8, bx));
    if (by < 10) by = R.y + CHAR_H + 15; // Below if no room above

    // Fade in/out
    const fadeIn = Math.min(1, (R.speechTimer > 40) ? 1 : R.speechTimer / 40);
    const alpha = fadeIn;

    ctx.save();
    ctx.globalAlpha = alpha;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    roundRect(ctx, bx + 3, by + 3, bubbleW, bubbleH, 10);
    ctx.fill();

    // Bubble
    ctx.fillStyle = 'rgba(5, 5, 15, 0.92)';
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 2;
    ctx.beginPath();
    roundRect(ctx, bx, by, bubbleW, bubbleH, 10);
    ctx.fill();
    ctx.stroke();

    // Pointer
    const pointerX = Math.max(bx + 15, Math.min(bx + bubbleW - 15, R.x + CHAR_W / 2));
    const pointerBaseY = (by > R.y) ? by : by + bubbleH;
    const pointerTipY = (by > R.y) ? by - 10 : by + bubbleH + 10;
    ctx.fillStyle = 'rgba(5, 5, 15, 0.92)';
    ctx.beginPath();
    ctx.moveTo(pointerX - 8, pointerBaseY);
    ctx.lineTo(pointerX, pointerTipY);
    ctx.lineTo(pointerX + 8, pointerBaseY);
    ctx.fill();
    ctx.strokeStyle = '#00ff88';
    ctx.beginPath();
    ctx.moveTo(pointerX - 8, pointerBaseY);
    ctx.lineTo(pointerX, pointerTipY);
    ctx.lineTo(pointerX + 8, pointerBaseY);
    ctx.stroke();

    // Text
    ctx.font = '14px "Courier New",monospace';
    ctx.fillStyle = '#00ff88';
    ctx.textAlign = 'center';
    lines.forEach((line, i) => {
        ctx.fillText(line, bx + bubbleW / 2, by + padding + 14 + i * lineHeight);
    });

    ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
}

// ============================================
// CATCH MECHANIC & UNIVERSE REVEAL
// ============================================
let universeReveal = { active: false, radius: 0, targetRadius: 0, alpha: 0, text: '' };

function catchRaanman() {
    R.state = 'caught';
    R.catchTimer = 700;
    R.caughtCount++;
    R.vx = 0; R.vy = 0;
    R.revelationShown = false;
    if (R.carrying) { // Drop what you're carrying!
        scatteredMaterials.push({ x: R.x, y: R.y + CHAR_H - 12, w: 10, h: 8, color: R.carrying.color, label: R.carrying.label || '', bobPhase: Math.random() * Math.PI * 2, alpha: 1, sparkle: 0 });
        R.carrying = null;
    }

    for (let i = 0; i < 50; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H/2, 'universe');
    for (let i = 0; i < 15; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H/2, 'star');
}

function drawUniverseReveal(time) {
    if (!universeReveal.active) return;
    universeReveal.radius += (universeReveal.targetRadius - universeReveal.radius) * 0.03;
    universeReveal.alpha = Math.min(universeReveal.alpha + 0.008, 0.85);

    const cx = canvas.width / 2, cy = canvas.height / 2;
    ctx.save();

    const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, universeReveal.radius);
    rg.addColorStop(0, `rgba(20,0,50,${universeReveal.alpha})`);
    rg.addColorStop(0.5, `rgba(0,20,40,${universeReveal.alpha * 0.8})`);
    rg.addColorStop(1, 'transparent');
    ctx.fillStyle = rg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (universeReveal.radius > 50) {
        ctx.strokeStyle = `rgba(0,255,136,${universeReveal.alpha * 0.3})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(cx, cy, universeReveal.radius * (0.3 + i * 0.2),
                time * 0.001 + i, time * 0.001 + i + Math.PI * 1.5);
            ctx.stroke();
        }
    }

    if (universeReveal.radius > 200 && universeReveal.text) {
        const ta = Math.min(1, (universeReveal.radius - 200) / 100);
        ctx.globalAlpha = ta;
        ctx.font = '22px "Courier New",monospace';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 20;
        universeReveal.text.split('\n').forEach((line, i, arr) => {
            ctx.fillText(line, cx, cy - (arr.length * 14) + i * 30);
        });
    }
    ctx.restore();
}

// ============================================
// CUSTOM CURSOR
// ============================================
function drawCursor(time) {
    if (!mouse.active) return;
    ctx.save();
    const pulse = Math.sin(time * 0.005) * 3;
    ctx.strokeStyle = `rgba(0,255,136,0.5)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 12 + pulse, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = `rgba(0,255,136,0.8)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(mouse.x - 6, mouse.y); ctx.lineTo(mouse.x + 6, mouse.y);
    ctx.moveTo(mouse.x, mouse.y - 6); ctx.lineTo(mouse.x, mouse.y + 6);
    ctx.stroke();
    ctx.restore();
}

// ============================================
// MOUSE
// ============================================
let mouse = { x: -1000, y: -1000, vx: 0, vy: 0, active: false };
let lastMouseMove = 0;

document.addEventListener('mousemove', e => {
    mouse.vx = e.clientX - mouse.x;
    mouse.vy = e.clientY - mouse.y;
    mouse.x = e.clientX;
    mouse.y = e.clientY;
    mouse.active = true;
    lastMouseMove = performance.now();
});
document.addEventListener('mouseleave', () => { mouse.active = false; });
document.addEventListener('mouseenter', () => { mouse.active = true; });
document.addEventListener('click', e => {
    if (R.state === 'caught') return;
    const dx = e.clientX - (R.x + CHAR_W/2);
    const dy = e.clientY - (R.y + CHAR_H/2);
    if (Math.sqrt(dx*dx + dy*dy) < 45) {
        catchRaanman();
    } else if (R.state !== 'sleep') {
        showSpeech(ONELINERS[Math.floor(Math.random() * ONELINERS.length)]);
        R.state = 'idle';
        R.idleTimer = 180;
    }
});

// ============================================
// RAANMAN AI
// ============================================
function findPlatformBelow(x, y) {
    let best = null;
    let bestY = Infinity;
    platforms.forEach(p => {
        if (x + CHAR_W > p.x + 5 && x < p.x + p.w - 5 && p.y >= y + CHAR_H - 2 && p.y < bestY) {
            best = p;
            bestY = p.y;
        }
    });
    return best;
}

function findNearbyPlatform(preferHigher) {
    const feetY = R.y + CHAR_H;
    const candidates = platforms.filter(p => {
        if (p.type === 'ground') return false;
        const dx = Math.abs((p.x + p.w/2) - (R.x + CHAR_W/2));
        const heightDiff = feetY - p.y; // positive = platform is above
        // Can reach platforms up to ~250px above (vy=-18, gravity 0.55)
        // and within ~300px horizontally
        if (dx > 300) return false;
        if (heightDiff > 250) return false; // too high to reach
        if (heightDiff < -400) return false; // way below, not interesting
        if (Math.abs(heightDiff) < 15 && dx < 40) return false; // too close / same level
        return true;
    });
    if (candidates.length === 0) return null;
    if (preferHigher) {
        // Sort by height (prefer higher platforms)
        candidates.sort((a, b) => a.y - b.y);
        // Pick from top third
        const pick = Math.floor(Math.random() * Math.max(1, Math.ceil(candidates.length / 3)));
        return candidates[pick];
    }
    return candidates[Math.floor(Math.random() * candidates.length)];
}

function jumpToPlatform(target) {
    const feetY = R.y + CHAR_H;
    const heightDiff = feetY - target.y; // positive = platform above
    const dx = (target.x + target.w/2) - (R.x + CHAR_W/2);
    const gravity = 0.55;

    // Calculate jump velocity needed: v = sqrt(2 * g * h) + extra headroom
    // We need to reach heightDiff pixels above, plus some margin
    const neededHeight = Math.max(40, heightDiff + 30);
    let jumpVy = -Math.sqrt(2 * gravity * neededHeight);
    jumpVy = Math.max(-20, Math.min(-8, jumpVy)); // Clamp between -8 and -20

    // Time to reach peak: t = |vy| / gravity
    // Total air time: roughly 2 * peak time
    const peakTime = Math.abs(jumpVy) / gravity;
    const totalTime = peakTime * 2;

    // Horizontal velocity to cover distance in that time
    // Account for air friction (0.96 per frame average)
    let jumpVx = dx / (totalTime * 0.7); // 0.7 to account for friction
    jumpVx = Math.max(-10, Math.min(10, jumpVx)); // Clamp

    R.vy = jumpVy;
    R.vx = jumpVx;
    R.grounded = false;
    R.squash = 1.3; R.stretch = 0.7;
    R.state = 'wander';
    R.wanderTimer = Math.max(60, totalTime + 30);
    R.facing = dx > 0 ? 1 : -1;

    for (let i = 0; i < 3; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dust');
}

function updateRaanman(time) {
    R.legAnim += Math.abs(R.vx) * 0.5 + (R.state === 'flee' ? 2 : 0);

    // Speech
    if (R.speechTimer > 0) R.speechTimer--;

    // Dust when running on ground
    if (R.grounded && Math.abs(R.vx) > 2) {
        R.dustTimer++;
        if (R.dustTimer % 5 === 0) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dust');
    }

    // Squash/stretch recovery
    R.squash += (1 - R.squash) * 0.15;
    R.stretch += (1 - R.stretch) * 0.15;

    // ---- CAUGHT STATE ----
    if (R.state === 'caught') {
        R.catchTimer--;
        R.glowRadius = Math.min(R.glowRadius + 2, 80);
        if (R.catchTimer < 580 && !R.revelationShown) {
            R.revelationShown = true;
            const rev = CAUGHT_REVELATIONS[Math.floor(Math.random() * CAUGHT_REVELATIONS.length)];
            showSpeech(rev, 500);
            universeReveal.active = true;
            universeReveal.radius = 0;
            universeReveal.targetRadius = Math.max(canvas.width, canvas.height);
            universeReveal.alpha = 0;
            universeReveal.text = rev;
        }
        if (R.catchTimer % 4 === 0) {
            spawnParticle(R.x + CHAR_W/2 + (Math.random()-0.5)*40,
                R.y + CHAR_H/2 + (Math.random()-0.5)*40, 'universe');
        }
        if (R.catchTimer <= 0) {
            R.state = 'idle';
            R.idleTimer = 180;
            R.glowRadius = 0;
            universeReveal.active = false;
            showSpeech("...where was I?\nOh right.\n*resumes being your\ndigital pet*");
        }
        return;
    }

    // ---- SLEEP STATE ----
    if (R.state === 'sleep') {
        R.sleepTimer--;
        if (R.sleepTimer % 50 === 0) spawnParticle(R.x + CHAR_W + 5, R.y + 10, 'zzz');
        const dx = mouse.x - R.x, dy = mouse.y - R.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if ((mouse.active && dist < R.awareness) || R.sleepTimer <= 0) {
            R.state = 'idle';
            R.idleTimer = 90;
            if (dist < R.awareness) showSpeech("*yawn* ...was I sleeping\non the job again?");
        }
        return;
    }

    // ---- MOUSE FLEE ----
    if (mouse.active) {
        const dx = mouse.x - (R.x + CHAR_W/2);
        const dy = mouse.y - (R.y + CHAR_H/2);
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Predict cursor
        const predX = mouse.x + mouse.vx * 10;
        const predY = mouse.y + mouse.vy * 10;
        const pdx = predX - (R.x + CHAR_W/2);
        const pdy = predY - (R.y + CHAR_H/2);
        const predDist = Math.sqrt(pdx*pdx + pdy*pdy);
        const effectiveDist = Math.min(dist, predDist);

        if (effectiveDist < R.awareness) {
            R.panicLevel = Math.min(1, R.panicLevel + 0.04);
            R.state = 'flee';
            if (R.carrying) { // Drop what you're carrying!
                scatteredMaterials.push({ x: R.x, y: R.y + CHAR_H - 12, w: 10, h: 8, color: R.carrying.color, label: R.carrying.label || '', bobPhase: Math.random() * Math.PI * 2, alpha: 1, sparkle: 0 });
                R.carrying = null;
            }

            // Flee direction
            const fleeX = (mouse.x + predX) / 2;
            const fleeDx = R.x - fleeX;
            const fleeLen = Math.abs(fleeDx) || 1;
            const panic = 1 + R.panicLevel * 2;
            R.vx += (fleeDx / fleeLen) * R.fleeSpeed * 0.15 * panic;

            // Jump away if close + mouse is fast
            const mouseSpd = Math.sqrt(mouse.vx*mouse.vx + mouse.vy*mouse.vy);
            if (effectiveDist < 100 && R.grounded && mouseSpd > 3) {
                R.vy = -14 - Math.random() * 4;
                R.grounded = false;
                R.squash = 1.3; R.stretch = 0.7;
                for (let i = 0; i < 5; i++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dollar');
            }

            // Try jumping to higher platform to escape
            if (effectiveDist < 120 && R.grounded && Math.random() < 0.06) {
                const target = findNearbyPlatform(true);
                if (target && target.y < R.y) {
                    jumpToPlatform(target);
                }
            }

            // Scared speech
            if (effectiveDist < 60 && R.speechTimer <= 0) {
                showSpeech(["AAHH!! TOO CLOSE!","nononono not again!",
                    "I HAVE A FIREWALL!","MY PERSONAL SPACE!",
                    "CURSOR DETECTED!!","EXCEPTION THROWN!",
                    "*screams in JavaScript*"][Math.floor(Math.random()*7)], 80);
            }
        } else {
            R.panicLevel = Math.max(0, R.panicLevel - 0.01);
            if (R.state === 'flee') {
                R.state = 'wander';
                R.wanderTimer = 100 + Math.random() * 200;
            }
        }
    } else {
        R.panicLevel = Math.max(0, R.panicLevel - 0.02);
    }

    // ---- IDLE ----
    if (R.state === 'idle') {
        R.idleTimer--;
        R.vx *= 0.85;

        if (R.idleTimer <= 0) {
            const roll = Math.random();
            if (roll < 0.35) {
                R.state = 'wander';
                R.wanderTimer = 100 + Math.random() * 250;
                R.wanderDir = Math.random() > 0.5 ? 1 : -1;
            } else if (roll < 0.65) {
                // Jump to a platform!
                const target = findNearbyPlatform(true);
                if (target && R.grounded) {
                    jumpToPlatform(target);
                } else {
                    R.state = 'wander';
                    R.wanderTimer = 120;
                    R.wanderDir = Math.random() > 0.5 ? 1 : -1;
                }
            } else if (roll < 0.78) {
                // Random jump
                if (R.grounded) {
                    R.vy = -9 - Math.random() * 5;
                    R.grounded = false;
                    R.squash = 1.2; R.stretch = 0.8;
                    R.state = 'wander';
                    R.wanderTimer = 60;
                    R.wanderDir = Math.random() > 0.5 ? 1 : -1;
                }
            } else if (roll < 0.92) {
                // Start building!
                if (!currentBlueprint && buildCooldown <= 0) {
                    startBuildProject();
                    R.state = 'gather';
                    R.buildTimer = 600;
                    const bp = currentBlueprint;
                    showSpeech("Time to build\n" + bp.name + "...\n*cracks knuckles*");
                } else if (currentBlueprint && buildStepIndex < currentBlueprint.blocks.length) {
                    R.state = 'gather';
                    R.buildTimer = 400;
                } else {
                    R.state = 'wander';
                    R.wanderTimer = 100;
                    R.wanderDir = Math.random() > 0.5 ? 1 : -1;
                }
            } else {
                R.state = 'sleep';
                R.sleepTimer = 400 + Math.random() * 500;
                showSpeech("*yawn*\ndigital pets need\ndigital naps...");
            }
        }
    }

    // ---- GATHER: walk to material and pick it up ----
    if (R.state === 'gather') {
        R.buildTimer--;

        // Bail if project was destroyed
        if (!currentBlueprint || buildStepIndex >= currentBlueprint.blocks.length) {
            R.carrying = null;
            R.state = 'idle';
            R.idleTimer = 100;
        }

        if (R.state === 'gather' && !R.carrying) {
            // Find nearest material
            if (scatteredMaterials.length === 0) scatterMaterials();
            const mat = findNearestMaterial();
            if (mat) {
                R.gatherTarget = mat;
                const dx = mat.x - (R.x + CHAR_W / 2);
                if (Math.abs(dx) > 20) {
                    R.vx += Math.sign(dx) * 0.5;
                    R.vx = Math.max(-R.maxSpeed, Math.min(R.maxSpeed, R.vx));
                    R.facing = dx > 0 ? 1 : -1;
                } else {
                    // Pick it up!
                    R.carrying = { color: mat.color, label: mat.label };
                    const idx = scatteredMaterials.indexOf(mat);
                    if (idx >= 0) scatteredMaterials.splice(idx, 1);
                    R.gatherTarget = null;
                    spawnParticle(R.x + CHAR_W/2, R.y, 'glow');
                    R.state = 'build';
                    R.buildPlaceTimer = 40 + Math.random() * 30;
                }
            } else {
                scatterMaterials();
            }
        }

        if (R.buildTimer <= 0 && !R.carrying) {
            R.state = 'idle';
            R.idleTimer = 80;
        }
    }

    // ---- BUILD: carry material to build site and place it ----
    if (R.state === 'build') {

        if (R.carrying && currentBlueprint && buildStepIndex < currentBlueprint.blocks.length) {
            // Walk toward build site
            const targetX = buildSiteX + currentBlueprint.blocks[buildStepIndex][0] * (BLOCK_SIZE + 1);
            const dx = targetX - (R.x + CHAR_W / 2);

            if (Math.abs(dx) > 15) {
                R.vx += Math.sign(dx) * 0.4;
                R.vx = Math.max(-R.maxSpeed * 0.8, Math.min(R.maxSpeed * 0.8, R.vx));
                R.facing = dx > 0 ? 1 : -1;
            } else {
                R.buildPlaceTimer--;
                R.vx *= 0.7; // Slow down while placing
                if (R.buildPlaceTimer <= 0) {
                    // Place the block!
                    const more = placeNextBuildBlock();
                    R.carrying = null;

                    // Build commentary
                    if (R.speechTimer <= 0 && Math.random() < 0.4 && currentBlueprint) {
                        const lines = currentBlueprint.buildLines;
                        showSpeech(lines[Math.floor(Math.random() * lines.length)]);
                    }

                    if (more && scatteredMaterials.length > 0) {
                        R.state = 'gather';
                        R.buildTimer = 300;
                    } else if (more) {
                        scatterMaterials();
                        R.state = 'gather';
                        R.buildTimer = 300;
                    } else {
                        // Done building!
                        showSpeech("*steps back*\n" + currentBlueprint.name + "\nis complete.\n*chef's kiss*", 400);
                        currentBlueprint = null;
                        buildCooldown = 1200; // Wait before building again
                        R.state = 'idle';
                        R.idleTimer = 300;
                    }
                }
            }
        } else {
            // Lost the project mid-build
            R.carrying = null;
            R.state = 'idle';
            R.idleTimer = 100;
        }
    }

    // ---- WANDER ----
    if (R.state === 'wander') {
        R.wanderTimer--;
        R.vx += R.wanderDir * 0.3;
        R.vx = Math.max(-R.maxSpeed, Math.min(R.maxSpeed, R.vx));

        // Occasionally jump to a platform while wandering
        if (R.grounded && R.wanderTimer > 30 && Math.random() < 0.008) {
            const target = findNearbyPlatform(Math.random() > 0.5);
            if (target) jumpToPlatform(target);
        }

        if (R.wanderTimer <= 0) {
            R.state = 'idle';
            R.idleTimer = 60 + Math.random() * 150;
        }
    }

    // ---- PHYSICS ----
    // Less friction while airborne so jumps actually reach platforms
    const airborne = !R.grounded;
    R.vx *= R.state === 'flee' ? 0.94 : (airborne ? 0.98 : 0.91);
    const maxSpd = R.state === 'flee' ? R.fleeSpeed * (1 + R.panicLevel) : (airborne ? 10 : R.maxSpeed);
    R.vx = Math.max(-maxSpd, Math.min(maxSpd, R.vx));

    // Gravity
    if (!R.grounded) {
        R.vy += 0.55;
        R.y += R.vy;
    }

    // Platform collision
    if (R.vy >= 0) {
        const plat = findPlatformBelow(R.x + 4, R.y);
        if (plat && R.y + CHAR_H >= plat.y && R.y + CHAR_H <= plat.y + 20) {
            R.y = plat.y - CHAR_H;
            R.vy = 0;
            if (!R.grounded) {
                R.squash = 0.7; R.stretch = 1.3;
                for (let i = 0; i < 4; i++) spawnParticle(R.x + CHAR_W/2 + (Math.random()-0.5)*15, R.y + CHAR_H, 'dust');
            }
            R.grounded = true;
            R.currentPlatform = plat;
        } else if (R.grounded && R.currentPlatform) {
            // Check if still on platform
            const p = R.currentPlatform;
            if (R.x + CHAR_W < p.x + 2 || R.x > p.x + p.w - 2) {
                R.grounded = false;
                R.currentPlatform = null;
            }
        }
    } else {
        R.grounded = false;
        R.currentPlatform = null;
    }

    // Fallback: don't fall below ground
    const ground = platforms.find(p => p.type === 'ground');
    if (ground && R.y + CHAR_H > ground.y) {
        R.y = ground.y - CHAR_H;
        R.vy = 0;
        if (!R.grounded) {
            R.squash = 0.7; R.stretch = 1.3;
            for (let i = 0; i < 4; i++) spawnParticle(R.x + CHAR_W/2 + (Math.random()-0.5)*15, R.y + CHAR_H, 'dust');
        }
        R.grounded = true;
        R.currentPlatform = ground;
    }

    // Move
    R.x += R.vx;
    if (Math.abs(R.vx) > 0.5) R.facing = R.vx > 0 ? 1 : -1;

    // Wrap screen
    if (R.x < -CHAR_W - 10) R.x = canvas.width + 5;
    if (R.x > canvas.width + 10) R.x = -CHAR_W - 5;

    // Animation frame
    R.frameTimer++;
    if (R.frameTimer >= (R.state === 'flee' ? 3 : 8)) {
        R.frame = (R.frame + 1) % 2;
        R.frameTimer = 0;
    }
}

// ============================================
// DRAW RAANMAN
// ============================================
function drawRaanman(time) {
    ctx.save();

    // Glow
    const baseGlow = 15 + Math.sin(time * 0.003) * 5;
    const glowSize = R.state === 'caught' ? R.glowRadius : baseGlow;
    const cx = R.x + CHAR_W/2, cy = R.y + CHAR_H/2;
    const gg = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowSize);
    if (R.state === 'caught') {
        gg.addColorStop(0, 'rgba(255,255,255,0.15)');
        gg.addColorStop(0.5, 'rgba(0,255,200,0.08)');
        gg.addColorStop(1, 'transparent');
    } else {
        gg.addColorStop(0, 'rgba(0,255,136,0.07)');
        gg.addColorStop(1, 'transparent');
    }
    ctx.fillStyle = gg;
    ctx.fillRect(cx - glowSize, cy - glowSize, glowSize * 2, glowSize * 2);

    // Shadow
    const ground = platforms.find(p => p.type === 'ground');
    if (ground) {
        const shadowY = R.currentPlatform ? R.currentPlatform.y : ground.y;
        const jumpH = shadowY - (R.y + CHAR_H);
        const shadowScale = Math.max(0.3, 1 - jumpH / 200);
        ctx.fillStyle = `rgba(0,0,0,${0.25 * shadowScale})`;
        ctx.beginPath();
        ctx.ellipse(R.x + CHAR_W/2, shadowY, CHAR_W * 0.5 * shadowScale, 3 * shadowScale, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Panic shake
    let sx = 0, sy = 0;
    if (R.panicLevel > 0.5) {
        sx = (Math.random() - 0.5) * R.panicLevel * 4;
        sy = (Math.random() - 0.5) * R.panicLevel * 2;
    }

    // Idle bob
    let bobY = 0;
    if (R.state === 'idle' && R.grounded) bobY = Math.sin(time * 0.004) * 2;

    // Draw the body
    drawRaanmanBody(R.x + sx, R.y + bobY + sy, R.squash, R.stretch, R.facing);

    // Sweat when fleeing
    if (R.state === 'flee' && R.panicLevel > 0.3 && Math.floor(time / 200) % 2 === 0) {
        ctx.fillStyle = `rgba(100,180,255,${R.panicLevel})`;
        ctx.beginPath();
        const sweatX = R.x + (R.facing === 1 ? CHAR_W + 4 : -4);
        ctx.arc(sweatX, R.y + 12 + Math.sin(time * 0.01) * 3, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// ============================================
// HUD
// ============================================
function drawHUD(time) {
    ctx.save();
    ctx.font = '11px "Courier New",monospace';
    ctx.fillStyle = `rgba(0,255,136,${R.state === 'sleep' ? 0.2 : 0.5})`;
    ctx.textAlign = 'center';
    ctx.fillText('ASMRaanman', R.x + CHAR_W/2, R.y - 8);

    ctx.textAlign = 'right';
    ctx.font = '12px "Courier New",monospace';
    ctx.fillStyle = 'rgba(0,255,136,0.25)';
    ctx.fillText(`catches: ${R.caughtCount}`, canvas.width - 15, 25);

    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,255,136,0.12)';
    ctx.font = '10px "Courier New",monospace';
    const stateText = R.state === 'flee' ? 'EVADING' :
        R.state === 'caught' ? 'ENLIGHTENED' :
        R.state === 'sleep' ? 'ZzZzZ...' :
        R.state === 'wander' ? 'exploring...' : 'vibing';

    // Pet mood indicator
    ctx.fillStyle = 'rgba(0,255,136,0.08)';
    ctx.font = '9px "Courier New",monospace';
    const mood = R.panicLevel > 0.5 ? 'PANICKED' :
        R.state === 'caught' ? 'TRANSCENDENT' :
        R.state === 'sleep' ? 'DREAMING' :
        R.caughtCount > 5 ? 'TRUSTS YOU' :
        R.caughtCount > 2 ? 'WARMING UP' : 'SHY';
    ctx.fillText(`mood: ${mood}`, 15, canvas.height - 30);
    ctx.fillText(`> ${stateText}`, 15, canvas.height - 15);

    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,255,136,0.06)';
    ctx.fillText('ASMRaanman // your digital pet // raanman.lol', canvas.width / 2, canvas.height - 10);
    ctx.restore();
}

// ============================================
// SIDE CHARACTERS: SPERRING & SYDNEY
// They pop in, chase Raanman, then disappear!
// ============================================
const sideChars = [];

const SPERRING_LINES = [
    "RAANMAN! Code review!",
    "Your PR has conflicts!",
    "The build is broken!",
    "Stand-up in 2 minutes!",
    "Did you push to main?!",
    "WHERE ARE THE TESTS?!",
];
const SYDNEY_LINES = [
    "Raanman! Deploy time!",
    "The client wants changes!",
    "Sprint retrospective NOW!",
    "Your branch is 47\ncommits behind!",
    "Raanman, JIRA is on fire!",
    "The deadline moved UP!",
];

function drawSperring(x, y, facing, frame) {
    ctx.save();
    const bx = x, by = y + 50;
    ctx.translate(x + 15, y + 50);
    ctx.scale(facing, 1);
    ctx.translate(-(x + 15), -(y + 50));

    // Hoodie body
    ctx.fillStyle = '#2244aa';
    ctx.fillRect(bx + 4, by - 28, 22, 23);

    // Hood
    ctx.fillStyle = '#1a3388';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 32, 14, Math.PI, 0);
    ctx.fill();
    ctx.fillRect(bx + 1, by - 32, 28, 6);

    // Face peeking out
    ctx.fillStyle = '#e8c89e';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 34, 9, 0, Math.PI * 2);
    ctx.fill();

    // Beady eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(bx + 10, by - 36, 3, 3);
    ctx.fillRect(bx + 17, by - 36, 3, 3);

    // Determined mouth
    ctx.strokeStyle = '#994433';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(bx + 11, by - 30);
    ctx.lineTo(bx + 19, by - 30);
    ctx.stroke();

    // Arms reaching forward (chasing!)
    ctx.fillStyle = '#2244aa';
    const armReach = Math.sin(frame * 0.4) * 6;
    ctx.fillRect(bx + 26, by - 24 + armReach, 10, 5);
    ctx.fillRect(bx + 26, by - 18 - armReach, 10, 5);

    // Legs
    ctx.fillStyle = '#333';
    const legAnim = Math.sin(frame * 0.5) * 5;
    ctx.fillRect(bx + 7, by - 5 - legAnim, 6, 10 + legAnim);
    ctx.fillRect(bx + 17, by - 5 + legAnim, 6, 10 - legAnim);

    // Shoes
    ctx.fillStyle = '#cc3333';
    ctx.fillRect(bx + 5, by + 4 - legAnim, 9, 3);
    ctx.fillRect(bx + 16, by + 4 + legAnim, 9, 3);

    ctx.restore();
}

function drawSydney(x, y, facing, frame) {
    ctx.save();
    const bx = x, by = y + 50;
    ctx.translate(x + 15, y + 50);
    ctx.scale(facing, 1);
    ctx.translate(-(x + 15), -(y + 50));

    // Purple jacket body
    ctx.fillStyle = '#7733aa';
    ctx.fillRect(bx + 4, by - 28, 22, 23);

    // Collar
    ctx.fillStyle = '#8844bb';
    ctx.fillRect(bx + 2, by - 30, 26, 5);

    // Head
    ctx.fillStyle = '#f0d0a0';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 38, 11, 0, Math.PI * 2);
    ctx.fill();

    // Hair (ponytail)
    ctx.fillStyle = '#442200';
    ctx.beginPath();
    ctx.arc(bx + 15, by - 40, 11, Math.PI + 0.3, -0.3);
    ctx.fill();
    // Ponytail
    ctx.fillRect(bx - 2, by - 42, 6, 16);
    ctx.beginPath();
    ctx.arc(bx + 1, by - 26, 3, 0, Math.PI * 2);
    ctx.fill();

    // Big round glasses
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(bx + 11, by - 38, 5, 0, Math.PI * 2);
    ctx.arc(bx + 21, by - 38, 5, 0, Math.PI * 2);
    ctx.stroke();
    // Glasses bridge
    ctx.beginPath();
    ctx.moveTo(bx + 16, by - 38);
    ctx.lineTo(bx + 16, by - 38);
    ctx.stroke();
    // Note: bridge is tiny at this scale - lenses are adjacent

    // Eyes behind glasses
    ctx.fillStyle = '#111';
    ctx.fillRect(bx + 10, by - 39, 2, 2);
    ctx.fillRect(bx + 20, by - 39, 2, 2);

    // Determined grin
    ctx.strokeStyle = '#aa5544';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(bx + 15, by - 32, 4, 0.2, Math.PI - 0.2);
    ctx.stroke();

    // Arms reaching
    ctx.fillStyle = '#7733aa';
    const armReach = Math.sin(frame * 0.4 + 1) * 6;
    ctx.fillRect(bx + 26, by - 22 + armReach, 10, 5);
    ctx.fillRect(bx + 26, by - 16 - armReach, 10, 5);

    // Legs
    ctx.fillStyle = '#222244';
    const legAnim = Math.sin(frame * 0.5) * 5;
    ctx.fillRect(bx + 7, by - 5 - legAnim, 6, 10 + legAnim);
    ctx.fillRect(bx + 17, by - 5 + legAnim, 6, 10 - legAnim);

    // Boots
    ctx.fillStyle = '#553388';
    ctx.fillRect(bx + 5, by + 4 - legAnim, 9, 3);
    ctx.fillRect(bx + 16, by + 4 + legAnim, 9, 3);

    ctx.restore();
}

function spawnSideCharacter() {
    if (sideChars.length > 0) return; // Only one at a time
    if (R.state === 'caught' || R.state === 'sleep') return;

    const isSperring = Math.random() > 0.5;
    const fromLeft = Math.random() > 0.5;
    const ground = platforms.find(p => p.type === 'ground');
    const groundY = ground ? ground.y - 55 : canvas.height - 95;

    const sc = {
        type: isSperring ? 'sperring' : 'sydney',
        x: fromLeft ? -40 : canvas.width + 40,
        y: groundY,
        vx: 0,
        facing: fromLeft ? 1 : -1,
        frame: 0,
        lifetime: 400 + Math.random() * 200,
        speed: 5 + Math.random() * 2,
        speechTimer: 0,
        speechText: null,
        hasSpokeEntry: false,
        hasSpokeChase: false,
        fading: false,
        alpha: 0,
    };

    sideChars.push(sc);
}

function updateSideCharacters() {
    for (let i = sideChars.length - 1; i >= 0; i--) {
        const sc = sideChars[i];
        sc.frame++;
        sc.lifetime--;

        // Fade in
        if (sc.alpha < 1 && !sc.fading) sc.alpha = Math.min(1, sc.alpha + 0.05);

        // Entry speech
        if (!sc.hasSpokeEntry && sc.alpha > 0.5) {
            sc.hasSpokeEntry = true;
            const lines = sc.type === 'sperring' ? SPERRING_LINES : SYDNEY_LINES;
            sc.speechText = lines[Math.floor(Math.random() * lines.length)];
            sc.speechTimer = 150;
        }

        // Chase Raanman!
        const dx = (R.x + CHAR_W/2) - (sc.x + 15);
        sc.facing = dx > 0 ? 1 : -1;
        sc.vx = Math.sign(dx) * sc.speed;
        sc.x += sc.vx;

        // Make Raanman react
        const dist = Math.abs(dx);
        if (dist < 200 && R.state !== 'caught') {
            R.state = 'flee';
            R.panicLevel = Math.min(1, R.panicLevel + 0.03);
            const fleeDx = R.x - sc.x;
            R.vx += Math.sign(fleeDx) * 0.8;

            if (!sc.hasSpokeChase && dist < 120) {
                sc.hasSpokeChase = true;
                const scares = [
                    "NOT " + (sc.type === 'sperring' ? 'SPERRING!' : 'SYDNEY!'),
                    "OH NO OH NO OH NO",
                    "THEY FOUND ME!",
                    "I'M ON BREAK!",
                    "MY PERSONAL SPACE!!",
                ];
                showSpeech(scares[Math.floor(Math.random() * scares.length)], 100);
                // Jump away!
                if (R.grounded) {
                    R.vy = -12;
                    R.grounded = false;
                    R.squash = 1.3; R.stretch = 0.7;
                    for (let j = 0; j < 5; j++) spawnParticle(R.x + CHAR_W/2, R.y + CHAR_H, 'dollar');
                }
            }
        }

        // Speech timer
        if (sc.speechTimer > 0) sc.speechTimer--;
        if (sc.speechTimer <= 0) sc.speechText = null;

        // Start fading out
        if (sc.lifetime < 60) {
            sc.fading = true;
            sc.alpha = Math.max(0, sc.alpha - 0.02);
        }

        // Remove
        if (sc.lifetime <= 0 || sc.alpha <= 0) {
            sideChars.splice(i, 1);
        }
    }
}

function drawSideCharacters(time) {
    sideChars.forEach(sc => {
        ctx.save();
        ctx.globalAlpha = sc.alpha;

        if (sc.type === 'sperring') {
            drawSperring(sc.x, sc.y, sc.facing, sc.frame);
        } else {
            drawSydney(sc.x, sc.y, sc.facing, sc.frame);
        }

        // Name tag
        ctx.font = '10px "Courier New",monospace';
        ctx.fillStyle = sc.type === 'sperring' ? '#4466cc' : '#aa55dd';
        ctx.textAlign = 'center';
        ctx.fillText(sc.type === 'sperring' ? 'Sperring' : 'Sydney', sc.x + 15, sc.y - 5);

        // Speech
        if (sc.speechText && sc.speechTimer > 0) {
            const lines = sc.speechText.split('\n');
            const lineH = 16;
            const pad = 10;
            const maxW = Math.max(...lines.map(l => l.length)) * 8;
            const bw = Math.max(maxW + pad * 2, 100);
            const bh = lines.length * lineH + pad * 2;
            let bx = sc.x + 15 - bw / 2;
            let by = sc.y - bh - 15;
            bx = Math.max(5, Math.min(canvas.width - bw - 5, bx));
            if (by < 5) by = sc.y + 60;

            const fadeA = Math.min(1, sc.speechTimer / 30);
            ctx.globalAlpha = sc.alpha * fadeA;

            ctx.fillStyle = 'rgba(10,10,30,0.9)';
            ctx.strokeStyle = sc.type === 'sperring' ? '#4466cc' : '#aa55dd';
            ctx.lineWidth = 2;
            ctx.beginPath();
            roundRect(ctx, bx, by, bw, bh, 8);
            ctx.fill();
            ctx.stroke();

            ctx.font = '12px "Courier New",monospace';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            lines.forEach((line, li) => {
                ctx.fillText(line, bx + bw / 2, by + pad + 12 + li * lineH);
            });
        }

        ctx.restore();
    });
}

// Spawn side characters every 30-60 seconds
let sideCharSpawnTimer = 0;
let sideCharSpawnThreshold = 1800 + Math.random() * 1800;

// ============================================
// MAIN LOOP
// ============================================
let ambientSpawnTimer = 0;

function loop(timestamp) {
    if (performance.now() - lastMouseMove > 5000) mouse.active = false;
    // Decay mouse velocity so stale values don't affect predictions
    if (performance.now() - lastMouseMove > 100) {
        mouse.vx *= 0.9; mouse.vy *= 0.9;
    }

    drawBackground(timestamp);
    ambientSpawnTimer++;
    if (ambientSpawnTimer % 120 === 0) spawnAmbientText();
    updateAmbientTexts();
    drawAmbientTexts();

    drawPlatforms(timestamp);

    // Build system
    updateBuildBlocks();
    drawScatteredMaterials(timestamp);
    drawBuildBlocks(timestamp);
    if (buildCooldown > 0) buildCooldown--;

    updateParticles();
    drawParticles();

    // Side characters
    sideCharSpawnTimer++;
    if (sideCharSpawnTimer > sideCharSpawnThreshold) {
        spawnSideCharacter();
        sideCharSpawnTimer = 0;
        sideCharSpawnThreshold = 1800 + Math.random() * 1800; // 30-60s
    }
    updateSideCharacters();

    updateRaanman(timestamp);
    drawRaanman(timestamp);
    drawSideCharacters(timestamp);
    drawSpeechBubble();
    drawUniverseReveal(timestamp);
    drawHUD(timestamp);
    drawCursor(timestamp);

    requestAnimationFrame(loop);
}

// Init
R.groundY = canvas.height - 40;
R.x = canvas.width / 2 - CHAR_W / 2;
R.y = R.groundY - CHAR_H;
generatePlatforms();

setTimeout(() => showSpeech("*adjusts tiny sunglasses*\n...oh, hi.\nI'm your digital pet now.\nPlease feed me commits."), 1000);

setInterval(() => {
    if (R.state !== 'caught' && R.state !== 'sleep' && R.speechTimer <= 0 && Math.random() < 0.3) {
        showSpeech(ONELINERS[Math.floor(Math.random() * ONELINERS.length)]);
    }
}, 10000);

window.addEventListener('resize', () => {
    resize();
    initBgStars();
    R.groundY = canvas.height - 40;
    if (R.y + CHAR_H > R.groundY) R.y = R.groundY - CHAR_H;
});

requestAnimationFrame(loop);
</script>
</body>
</html>
