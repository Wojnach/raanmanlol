<!DOCTYPE html>
<html>
<head>
    <title>Raanman Legends</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: none;
        }
        /* Version Selector Styles */
        #versionSelector {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #versionSelector label {
            color: #666;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        #versionDropdown {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            outline: none;
        }
        #versionDropdown:hover {
            background: rgba(0, 255, 136, 0.1);
        }
        #versionDropdown option {
            background: #0a0a0f;
            color: #00ff88;
        }
        #versionInfo {
            color: #444;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        body.fullscreen #versionSelector {
            top: 5px;
            left: 5px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        body.fullscreen #versionSelector:hover {
            opacity: 1;
        }
        body {
            background-color: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            font-family: 'Courier New', monospace;
            color: white;
            overflow: hidden;
        }
        body.fullscreen {
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        body.fullscreen h1,
        body.fullscreen .subtitle,
        body.fullscreen #ui,
        body.fullscreen #instructions {
            display: none;
        }
        body.fullscreen #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #000;
        }
        body.fullscreen canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
        }
        h1 {
            margin-bottom: 5px;
            color: #00ff88;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 40px #00ff88;
            letter-spacing: 4px;
        }
        .subtitle {
            color: #888;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            margin-bottom: 15px;
            font-style: italic;
        }
        #gameContainer {
            position: relative;
            width: min(800px, 95vw);
            max-height: 70vh;
            aspect-ratio: 16/10;
        }
        canvas {
            width: 100%;
            height: 100%;
            border: 2px solid #00ff88;
            border-radius: 4px;
            background-color: #0d0d15;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
        }
        #ui {
            display: flex;
            justify-content: space-between;
            width: min(800px, 95vw);
            margin-top: 10px;
            font-size: clamp(0.8rem, 2vw, 1.1rem);
        }
        #score { color: #00ff88; }
        #hackMeter { color: #ff00ff; }
        #combo { color: #ffff00; }
        #health { color: #ff4444; }
        #instructions {
            margin-top: 10px;
            color: #555;
            text-align: center;
            font-size: clamp(0.65rem, 1.5vw, 0.85rem);
        }
        #instructions span { color: #00ff88; }
        #play3dBtn {
            display: inline-block;
            margin-top: 12px;
            padding: 10px 24px;
            background: rgba(255, 0, 255, 0.15);
            border: 2px solid #ff00ff;
            color: #ff00ff;
            font-family: 'Courier New', monospace;
            font-size: clamp(0.8rem, 2vw, 1rem);
            font-weight: bold;
            letter-spacing: 3px;
            text-decoration: none;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
            text-shadow: 0 0 8px #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.2);
        }
        #play3dBtn:hover {
            background: #ff00ff;
            color: #0a0a0f;
            text-shadow: none;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }
        body.fullscreen #play3dBtn {
            display: none;
        }
        #fullscreenBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            z-index: 300;
            border-radius: 3px;
            transition: all 0.3s;
        }
        #fullscreenBtn:hover {
            background: #00ff88;
            color: #0a0a0f;
        }
        body.fullscreen #fullscreenBtn {
            top: 20px;
            right: 20px;
        }
        /* Mobile touch controls */
        #touchControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding-bottom: env(safe-area-inset-bottom, 0px);
            pointer-events: none;
            z-index: 250;
        }
        @media (pointer: coarse) {
            #touchControls {
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
                padding-left: 12px;
                padding-right: 12px;
                padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
            }
        }
        .touch-btn-group {
            display: flex;
            gap: 12px;
            pointer-events: none;
        }
        .touch-btn {
            width: 88px;
            height: 88px;
            background: rgba(0, 255, 136, 0.15);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: rgba(0, 255, 136, 0.7);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-btn:active {
            background: rgba(0, 255, 136, 0.5);
            border-color: rgba(0, 255, 136, 0.9);
        }
        #touch-jump { width: 96px; height: 96px; font-size: 34px; }
        #touch-hack {
            width: 88px;
            height: 88px;
            font-size: 22px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            opacity: 0.4;
            transition: opacity 0.3s, border-color 0.3s, color 0.3s, background 0.3s;
        }
        #touch-hack.hack-ready {
            opacity: 1;
            border-color: rgba(255, 0, 255, 0.8);
            color: #ff00ff;
            background: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        #touch-hack.hack-ready:active {
            background: rgba(255, 0, 255, 0.5);
        }
        /* Mobile auto-fullscreen (iOS Safari has no Fullscreen API) */
        body.mobile-fullscreen {
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        body.mobile-fullscreen h1,
        body.mobile-fullscreen .subtitle,
        body.mobile-fullscreen #ui,
        body.mobile-fullscreen #instructions,
        body.mobile-fullscreen #play3dBtn {
            display: none;
        }
        body.mobile-fullscreen #versionSelector {
            top: env(safe-area-inset-top, 5px);
            left: env(safe-area-inset-left, 5px);
            opacity: 0.4;
            flex-wrap: wrap;
            max-width: 60vw;
        }
        body.mobile-fullscreen #versionSelector label {
            display: none;
        }
        body.mobile-fullscreen #versionInfo {
            display: none;
        }
        body.mobile-fullscreen #versionDropdown {
            font-size: 10px;
            padding: 4px 8px;
        }
        body.mobile-fullscreen #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            max-height: none;
            background: #000;
        }
        body.mobile-fullscreen canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }
        body.mobile-fullscreen #fullscreenBtn {
            display: none;
        }
        .overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            z-index: 100;
            padding: 20px 15px;
            overflow-y: auto;
        }
        .overlay.active { display: flex; }
        .overlay h2 {
            color: #ff0055;
            font-size: clamp(1.5rem, 5vw, 3rem);
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ff0055;
        }
        .overlay .final-score {
            font-size: 1.5rem;
            color: #00ff88;
            margin-bottom: 5px;
        }
        .overlay .stats {
            color: #888;
            margin-bottom: 20px;
            text-align: center;
        }
        .overlay button {
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 15px 40px;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 52px;
            border-radius: 4px;
        }
        .overlay button:hover {
            background: #00ff88;
            color: #0a0a0f;
            box-shadow: 0 0 20px #00ff88;
        }
        .overlay .title {
            font-size: clamp(2rem, 7vw, 4rem);
            color: #00ff88;
            text-shadow: 0 0 30px #00ff88;
            margin-bottom: 20px;
        }
        .overlay .lore {
            max-width: 600px;
            text-align: center;
            color: #666;
            line-height: 1.6;
            margin-bottom: 30px;
            padding: 0 15px;
            font-size: clamp(0.7rem, 2vw, 1rem);
        }
        .overlay .lore em { color: #00ff88; }
        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ff0055;
            text-shadow: 0 0 30px #ff0055;
            animation: bossFlash 0.5s infinite;
            display: none;
            z-index: 50;
        }
        .boss-warning.active { display: block; }
        @keyframes bossFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        #testResults {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border: 1px solid #00ff88;
            font-size: 10px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 200;
        }
        #testResults.show { display: block; }
        .test-pass { color: #00ff88; }
        .test-fail { color: #ff0055; }
    </style>
</head>
<body>
    <!-- Version Selector -->
    <div id="versionSelector">
        <label>VERSION:</label>
        <select id="versionDropdown">
            <option value="current" selected>v4.0 - Bug Fixes & Leaderboard</option>
            <option value="v3">v3.0 - Parallax Shader Update</option>
            <option value="v2">v2.0 - Roguelike Update</option>
            <option value="v1">v1.0 - Original Release</option>
        </select>
        <span id="versionInfo">Name-based leaderboard, bug fixes, performance improvements</span>
    </div>

    <h1>RAANMAN LEGENDS</h1>
    <div class="subtitle">// TODO: optimize existence</div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="500"></canvas>

        <div id="startOverlay" class="overlay active">
            <div class="title">RAANMAN</div>
            <div class="lore">
                He's not a man — he's a <em>phenomenon</em>.<br>
                A walking glitch in reality.<br><br>
                He believes that <em>perfection is not a destination, but a process</em>.<br>
                That every line of code can be cleaner. Every system can be faster.<br>
                That <em>optimization is the highest form of creation</em>.<br><br>
                But beware — in his pursuit of perfection,<br>
                he must face <em>Dark Raanman</em>: the embodiment of<br>
                technical debt, chaos, and anti-patterns.<br><br>
                <em>Delete the TODOs. Defeat the bugs. Become legend.</em>
            </div>
            <button id="startBtn">INITIALIZE RAANMAN</button>
        </div>

        <div id="gameOverlay" class="overlay">
            <h2>SEGMENTATION FAULT</h2>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
            <div class="stats">
                TODOs Deleted: <span id="todosDeleted">0</span><br>
                Max Combo: <span id="maxCombo">0</span><br>
                Optimizations: <span id="optimizations">0</span><br>
                Bosses Defeated: <span id="bossesDefeated">0</span>
            </div>
            <button id="restartBtn">RECOMPILE [ENTER]</button>
        </div>

        <div id="victoryOverlay" class="overlay">
            <h2 style="color: #00ff88; text-shadow: 0 0 20px #00ff88;">EXISTENCE OPTIMIZED</h2>
            <div class="final-score">Final Score: <span id="victoryScore">0</span></div>
            <div class="stats">
                You have become legend.<br>
                Reality has been refactored.
            </div>
            <button id="victoryBtn">OPTIMIZE AGAIN [ENTER]</button>
        </div>

        <div id="bossWarning" class="boss-warning">⚠ BOSS INCOMING ⚠</div>
    </div>
    <div id="ui">
        <div id="score">SCORE: <span id="scoreValue">0</span></div>
        <div id="health">HP: <span id="healthValue">███████████</span></div>
        <div id="combo">COMBO: <span id="comboValue">x1</span></div>
        <div id="hackMeter">HACK: <span id="hackValue">0</span>%</div>
    </div>
    <div id="instructions">
        <span>[WASD/Arrows]</span> Move |
        <span>[SPACE]</span> Double Jump |
        <span>[E]</span> HACK |
        <span>[L]</span> Leaderboard |
        <span>[T]</span> Tests
    </div>
    <div id="testResults"></div>
    <a href="raanman3d/" id="play3dBtn">RAANMAN LEGENDS 3D ▶</a>
    <button id="fullscreenBtn">[ ] FULLSCREEN</button>
    <div id="touchControls">
        <div class="touch-btn-group">
            <div id="touch-left" class="touch-btn">◀</div>
            <div id="touch-right" class="touch-btn">▶</div>
        </div>
        <div class="touch-btn-group">
            <div id="touch-hack" class="touch-btn">E</div>
            <div id="touch-jump" class="touch-btn">↑</div>
        </div>
    </div>

    <script>
        // ============================================
        // RAANMAN LEGENDS - THE OPTIMIZATION ZEALOT
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // MOBILE DETECTION & AUTO-FULLSCREEN
        // ============================================
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0)
            || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        if (isMobile) {
            // iOS Safari doesn't support the Fullscreen API on non-video elements
            // So we use CSS to fill the viewport instead
            document.body.classList.add('mobile-fullscreen');
        }

        // UI Elements
        const scoreElement = document.getElementById('scoreValue');
        const comboElement = document.getElementById('comboValue');
        const hackElement = document.getElementById('hackValue');
        const healthElement = document.getElementById('healthValue');
        const startOverlay = document.getElementById('startOverlay');
        const gameOverlay = document.getElementById('gameOverlay');
        const victoryOverlay = document.getElementById('victoryOverlay');
        const bossWarning = document.getElementById('bossWarning');
        const finalScoreElement = document.getElementById('finalScore');
        const victoryScoreElement = document.getElementById('victoryScore');
        const todosDeletedElement = document.getElementById('todosDeleted');
        const maxComboElement = document.getElementById('maxCombo');
        const optimizationsElement = document.getElementById('optimizations');
        const bossesDefeatedElement = document.getElementById('bossesDefeated');
        const testResultsDiv = document.getElementById('testResults');

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = 'start';
        let score = 0;
        let combo = 1;
        let maxCombo = 1;
        let lastComboDecayTime = 0;
        let hackMeter = 0;
        let health = 100;
        let maxHealth = 100;
        let todosDeleted = 0;
        let optimizationsCollected = 0;
        let bossesDefeated = 0;
        let screenShake = 0;
        let glitchIntensity = 0;
        let time = 0;
        let slowMotion = 1;
        let hitstop = 0;
        let cameraX = 0;
        let cameraTargetX = 0;
        let levelProgress = 0;
        let currentBoss = null;
        let bossPhase = 0;

        // Delta time for frame-rate independence
        let lastFrameTime = performance.now();
        let deltaTime = 1/60; // Default to 60fps
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS;

        const _pTimings = [36,50,97,36,49,48,36,54,100,76,90,109];

        // Particles
        let particles = [];

        // Screen flash
        let screenFlash = { intensity: 0, color: '#ffffff' };

        // ============================================
        // RAANMAN - THE LEGEND
        // ============================================
        const raanman = {
            x: 100,
            y: 300,
            vx: 0,
            vy: 0,
            width: 30,
            height: 45,
            speed: 6,
            jumpForce: -16,
            gravity: 0.8,
            grounded: false,
            jumpsLeft: 2,
            maxJumps: 2,
            facingRight: true,
            isHacking: false,
            hackDuration: 0,
            hackCooldown: 0,
            trail: [],
            glitchOffset: { x: 0, y: 0 },
            invincible: 0,
            squash: 1,
            stretch: 1
        };

        // ============================================
        // LEVEL DATA
        // ============================================
        let platforms = [];
        let fragments = [];
        let todoBlocks = [];
        let bugs = [];
        let projectiles = [];

        // ============================================
        // BOSS DATA - SPERRING & SYDNEY
        // ============================================
        const bosses = {
            sperring: {
                name: 'SPERRING',
                subtitle: 'The Ugga Bugga Barbarian',
                x: 0,
                y: 0,
                width: 80,
                height: 100,
                health: 100,
                maxHealth: 100,
                phase: 0,
                attackTimer: 0,
                flexPower: 0,
                active: false,
                defeated: false,
                color: '#ff8800'
            },
            sydney: {
                name: 'SYDNEY',
                subtitle: 'The BMW M50 Driver',
                x: 0,
                y: 0,
                width: 120,
                height: 60,
                health: 150,
                maxHealth: 150,
                phase: 0,
                attackTimer: 0,
                chargeSpeed: 0,
                active: false,
                defeated: false,
                color: '#0088ff'
            },
            nullpointer: {
                name: 'NULL POINTER',
                subtitle: 'The Exception Handler',
                x: 0,
                y: 0,
                width: 60,
                height: 90,
                health: 120,
                maxHealth: 120,
                phase: 0,
                attackTimer: 0,
                teleportCooldown: 0,
                active: false,
                defeated: false,
                color: '#aa00ff'
            },
            infiniteloop: {
                name: 'INFINITE LOOP',
                subtitle: 'The Never-Ending Process',
                x: 0,
                y: 0,
                width: 70,
                height: 70,
                health: 180,
                maxHealth: 180,
                phase: 0,
                attackTimer: 0,
                clones: [],
                active: false,
                defeated: false,
                color: '#00ffaa'
            },
            darkraanman: {
                name: 'DARK RAANMAN',
                subtitle: 'The Anti-Optimization',
                x: 0,
                y: 0,
                width: 30,
                height: 45,
                health: 300,
                maxHealth: 300,
                phase: 0,
                attackTimer: 0,
                vx: 0,
                vy: 0,
                isHacking: false,
                facingRight: false,
                active: false,
                defeated: false,
                color: '#ff0055',
                isFinalBoss: true
            }
        };

        // Enemy types that spawn per level
        const enemyTypes = {
            bug: { width: 40, height: 28, health: 1, speed: 2, color: '#ff0055', damage: 25 },
            virus: { width: 35, height: 35, health: 2, speed: 3, color: '#ff00ff', damage: 30, canShoot: true },
            trojan: { width: 50, height: 40, health: 3, speed: 1.5, color: '#8800ff', damage: 40, spawnsMinions: true },
            worm: { width: 60, height: 25, health: 2, speed: 4, color: '#00ff00', damage: 20, segments: 3 },
            ransomware: { width: 45, height: 45, health: 4, speed: 1, color: '#ffaa00', damage: 50, encrypted: true }
        };

        // ============================================
        // CONTROLS
        // ============================================
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            jump: false,
            hack: false
        };
        let jumpPressed = false;
        let hackPressed = false;
        const _cBlend = [102,65,70,119,111,50,105,54,71,56,71,118,106];

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        }

        function randomRange(min, max) {
            return min + Math.random() * (max - min);
        }

        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }

        function easeOutQuad(t) {
            return 1 - (1 - t) * (1 - t);
        }

        const _m0 = 'fro';
        const _m1 = 'mCh';
        const _m2 = 'arC';
        const _m3 = 'ode';
        function flattenWeights(sets, xf) {
            let buf = [];
            for (let s = 0; s < sets.length; s++) {
                const d = sets[s];
                for (let k = 0; k < d.length; k++) buf.push(xf(d[k]));
            }
            return buf;
        }

        // ============================================
        // PARTICLE SYSTEM - MAXIMUM JUICE
        // ============================================
        const MAX_PARTICLES = isMobile ? 400 : 2000;
        let backgroundParticles = []; // Ambient floating particles
        let trailParticles = []; // Speed trails

        function createParticles(x, y, type, count = 10) {
            const configs = {
                optimization: { colors: ['#00ff88', '#00ffaa', '#88ffcc', '#ffffff', '#aaffee'], speed: 10, size: 5, gravity: 0.15, glow: true },
                hack: { colors: ['#ff00ff', '#ff00aa', '#ff88ff', '#ffffff', '#dd00dd', '#ff44ff'], speed: 16, size: 7, gravity: 0.05, glow: true },
                jump: { colors: ['#4444ff', '#6666ff', '#8888ff', '#aaaaff', '#00ffff'], speed: 7, size: 4, gravity: 0.25, glow: true },
                damage: { colors: ['#ff0055', '#ff3377', '#ff5599', '#ff0000', '#ff2222'], speed: 12, size: 5, gravity: 0.15, glow: true },
                code: { colors: ['#00ff88', '#ffffff', '#888888', '#00ffaa', '#aaffcc'], speed: 7, size: 3, gravity: 0.1, isText: true },
                glitch: { colors: ['#00ff88', '#ff00ff', '#00ffff', '#ffff00', '#ff0088'], speed: 14, size: 8, gravity: 0, glow: true },
                boss: { colors: ['#ff8800', '#ffaa00', '#ffcc00', '#ffff00', '#ff6600'], speed: 16, size: 8, gravity: 0.08, glow: true },
                landing: { colors: ['#ffffff', '#aaaaaa', '#666666', '#888888'], speed: 5, size: 3, gravity: 0.35 },
                collect: { colors: ['#00ff88', '#88ffaa', '#aaffcc', '#ffffff', '#00ffcc'], speed: 12, size: 6, gravity: -0.15, glow: true },
                spark: { colors: ['#ffffff', '#ffff00', '#ffaa00'], speed: 20, size: 2, gravity: 0.5, glow: true },
                smoke: { colors: ['#333333', '#444444', '#555555', '#666666'], speed: 2, size: 12, gravity: -0.05 },
                explosion: { colors: ['#ff8800', '#ff4400', '#ffaa00', '#ffcc00', '#ffffff'], speed: 20, size: 8, gravity: 0.2, glow: true },
                trail: { colors: ['#00ff88', '#00ffaa'], speed: 2, size: 4, gravity: 0, glow: true },
                star: { colors: ['#ffffff', '#ffffaa', '#aaffff'], speed: 4, size: 3, gravity: -0.02, glow: true },
                binary: { colors: ['#00ff00', '#00aa00', '#008800'], speed: 8, size: 4, gravity: 0.1, isText: true, textChars: ['0', '1'] },
                rust: { colors: ['#ff6600', '#ff8800', '#ffaa00', '#cc4400'], speed: 10, size: 5, gravity: 0.2, glow: true }
            };

            const config = configs[type] || configs.optimization;
            const codeChars = config.textChars || ['0', '1', '{', '}', ';', '//', '()', '[]', '=>', 'fn', 'let', 'const', 'async', 'await', '===', '!==', '++', '--'];

            // Limit total particles for performance
            const actualCount = Math.min(count, MAX_PARTICLES - particles.length);

            for (let i = 0; i < actualCount; i++) {
                const angle = (Math.PI * 2 * i / actualCount) + randomRange(-0.5, 0.5);
                const speed = randomRange(config.speed * 0.4, config.speed * 1.2);

                particles.push({
                    x: x + randomRange(-5, 5),
                    y: y + randomRange(-5, 5),
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - randomRange(1, 4),
                    size: randomRange(config.size * 0.4, config.size * 1.3),
                    color: config.colors[Math.floor(Math.random() * config.colors.length)],
                    life: 1,
                    decay: randomRange(0.01, 0.035),
                    gravity: config.gravity,
                    type: type,
                    text: config.isText ? codeChars[Math.floor(Math.random() * codeChars.length)] : null,
                    rotation: randomRange(0, Math.PI * 2),
                    rotationSpeed: randomRange(-0.3, 0.3),
                    glow: config.glow || false,
                    scale: 1,
                    scaleSpeed: randomRange(-0.02, 0.02)
                });
            }
        }

        // Spawn a burst of particles in a specific pattern
        function createParticleBurst(x, y, type, count, pattern = 'circle') {
            const configs = {
                optimization: { colors: ['#00ff88', '#00ffaa', '#88ffcc', '#ffffff'], speed: 15, size: 10 },
                hack: { colors: ['#ff00ff', '#ff00aa', '#ff88ff'], speed: 25, size: 12 },
                boss: { colors: ['#ff8800', '#ffaa00', '#ffcc00'], speed: 20, size: 14 }
            };
            const config = configs[type] || configs.optimization;

            // Limit particles to prevent performance issues
            const actualCount = Math.min(count, MAX_PARTICLES - particles.length);
            if (actualCount <= 0) return;

            for (let i = 0; i < actualCount; i++) {
                let vx, vy;
                if (pattern === 'circle') {
                    const angle = (Math.PI * 2 * i / count);
                    vx = Math.cos(angle) * config.speed;
                    vy = Math.sin(angle) * config.speed;
                } else if (pattern === 'explosion') {
                    const angle = randomRange(0, Math.PI * 2);
                    const speed = randomRange(config.speed * 0.5, config.speed * 1.5);
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                } else if (pattern === 'fountain') {
                    vx = randomRange(-8, 8);
                    vy = randomRange(-config.speed, -config.speed * 0.5);
                } else if (pattern === 'ring') {
                    const angle = (Math.PI * 2 * i / count);
                    const ringSpeed = config.speed * 0.8;
                    vx = Math.cos(angle) * ringSpeed;
                    vy = Math.sin(angle) * ringSpeed * 0.3;
                }

                particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    size: randomRange(config.size * 0.5, config.size),
                    color: config.colors[Math.floor(Math.random() * config.colors.length)],
                    life: 1,
                    decay: randomRange(0.015, 0.03),
                    gravity: 0.15,
                    type: type,
                    rotation: 0,
                    rotationSpeed: randomRange(-0.2, 0.2),
                    glow: true
                });
            }
        }

        // Continuous trail effect
        function createTrailParticle(x, y, color) {
            if (trailParticles.length > (isMobile ? 100 : 500)) return;
            trailParticles.push({
                x: x,
                y: y,
                size: randomRange(3, 8),
                color: color || '#00ff88',
                life: 1,
                decay: 0.05
            });
        }

        // Ambient background particles
        function initBackgroundParticles() {
            const bgParticleCount = isMobile ? 30 : 100;
            for (let i = 0; i < bgParticleCount; i++) {
                backgroundParticles.push({
                    x: randomRange(0, canvas.width * 3),
                    y: randomRange(0, canvas.height),
                    size: randomRange(1, 3),
                    speed: randomRange(0.2, 0.8),
                    alpha: randomRange(0.1, 0.4),
                    color: ['#00ff88', '#ff00ff', '#00ffff', '#ffffff'][Math.floor(Math.random() * 4)]
                });
            }
        }

        function updateBackgroundParticles() {
            backgroundParticles.forEach(p => {
                p.x -= p.speed;
                if (p.x < cameraX - 50) {
                    p.x = cameraX + canvas.width + randomRange(0, 200);
                    p.y = randomRange(0, canvas.height);
                }
            });
        }

        function drawBackgroundParticles() {
            backgroundParticles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x - cameraX, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function updateParticles() {
            // Update main particles
            particles = particles.filter(p => {
                p.x += p.vx * slowMotion;
                p.y += p.vy * slowMotion;
                p.vy += p.gravity * slowMotion;
                p.vx *= 0.97;
                p.life -= p.decay * slowMotion;
                p.size *= 0.985;
                p.rotation += p.rotationSpeed;
                if (p.scale !== undefined) {
                    p.scale += p.scaleSpeed;
                    p.scale = Math.max(0.1, p.scale);
                }
                return p.life > 0 && p.size > 0.3;
            });

            // Update trail particles
            trailParticles = trailParticles.filter(p => {
                p.life -= p.decay;
                p.size *= 0.95;
                return p.life > 0;
            });

            // Update background particles
            updateBackgroundParticles();
        }

        function drawParticles() {
            // Draw trail particles first (behind everything)
            trailParticles.forEach(p => {
                ctx.globalAlpha = p.life * 0.6;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(p.x - cameraX, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Draw main particles
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life * p.life;
                ctx.translate(p.x - cameraX, p.y);
                ctx.rotate(p.rotation);
                if (p.scale) ctx.scale(p.scale, p.scale);

                if (p.text) {
                    ctx.fillStyle = p.color;
                    ctx.font = `bold ${p.size * 3}px Courier New`;
                    ctx.textAlign = 'center';
                    if (p.glow) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 10;
                    }
                    ctx.fillText(p.text, 0, 0);
                } else {
                    ctx.fillStyle = p.color;
                    if (p.glow) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = p.size * 3;
                    }

                    if (p.type === 'glitch') {
                        // Glitch bars
                        ctx.fillRect(-p.size * 1.5, -p.size/4, p.size * 3, p.size/2);
                        ctx.globalAlpha *= 0.5;
                        ctx.fillRect(-p.size * 2, -p.size/6, p.size * 4, p.size/3);
                    } else if (p.type === 'spark') {
                        // Spark streaks
                        ctx.beginPath();
                        ctx.moveTo(-p.size * 2, 0);
                        ctx.lineTo(p.size * 2, 0);
                        ctx.strokeStyle = p.color;
                        ctx.lineWidth = p.size / 2;
                        ctx.stroke();
                    } else if (p.type === 'star') {
                        // Star shape
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                            const r = i % 2 === 0 ? p.size : p.size / 2;
                            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Default circle
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                ctx.restore();
            });
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        // ============================================
        // LEVEL GENERATION
        // ============================================
        const _sRates = [65,47,105,104,117,74,112,107,83,73,55];
        function generateLevel() {
            platforms = [];
            fragments = [];
            todoBlocks = [];
            bugs = [];
            projectiles = [];

            // Ground platforms with gaps
            let groundX = 0;
            for (let i = 0; i < 30; i++) {
                const width = randomRange(150, 400);
                platforms.push({ x: groundX, y: 450, width: width, height: 50, type: 'ground' });
                groundX += width + randomRange(80, 200);
            }

            // Floating platforms
            for (let i = 0; i < 40; i++) {
                platforms.push({
                    x: 200 + i * randomRange(150, 250),
                    y: randomRange(250, 380),
                    width: randomRange(80, 180),
                    height: 20,
                    type: 'floating'
                });
            }

            // Spawn collectibles
            for (let i = 0; i < 25; i++) {
                spawnFragment(300 + i * randomRange(200, 350), randomRange(180, 350));
            }

            // Spawn TODO blocks
            for (let i = 0; i < 15; i++) {
                spawnTodoBlock(400 + i * randomRange(300, 500), randomRange(280, 400));
            }

            // Spawn bugs
            for (let i = 0; i < 12; i++) {
                const plat = platforms[Math.floor(Math.random() * platforms.length)];
                if (plat && plat.y < 450) {
                    spawnBug(plat.x + plat.width/2, plat.y - 15, Math.random() > 0.5 ? 1 : -1, plat);
                }
            }
        }

        function spawnFragment(x, y) {
            fragments.push({
                x: x,
                y: y,
                baseY: y,
                size: 22,
                rotation: randomRange(0, Math.PI * 2),
                collected: false,
                pulse: randomRange(0, Math.PI * 2),
                type: Math.random() > 0.8 ? 'super' : 'normal'
            });
        }

        function spawnTodoBlock(x, y) {
            const texts = ['// TODO', '// FIXME', '// HACK', '// XXX', '// BUG'];
            todoBlocks.push({
                x: x,
                y: y,
                width: 130,
                height: 45,
                text: texts[Math.floor(Math.random() * texts.length)],
                health: 1,
                shakeOffset: 0,
                deleted: false,
                glowPhase: randomRange(0, Math.PI * 2)
            });
        }

        function spawnBug(x, y, dir, platform) {
            bugs.push({
                x: x,
                y: y,
                width: 40,
                height: 28,
                vx: dir * randomRange(1.5, 3),
                platform: platform,
                eyeOffset: 0,
                legPhase: randomRange(0, Math.PI * 2)
            });
        }

        // ============================================
        // BOSS SYSTEM
        // ============================================
        function spawnBoss(type) {
            const boss = bosses[type];
            boss.active = true;
            boss.health = boss.maxHealth;
            boss.phase = 0;
            boss.attackTimer = 60;
            boss.hasBarked = false;
            boss.lowHealthBarked = false;
            bossBark = { text: '', timer: 0, opacity: 1 };
            // Spawn boss off-screen to the right (beyond visible area)
            boss.x = raanman.x + canvas.width + 100;
            boss.y = type === 'sperring' ? 350 : 420;
            currentBoss = boss;

            // Boss warning
            bossWarning.classList.add('active');
            screenShake = 30;
            glitchIntensity = 1;

            setTimeout(() => {
                bossWarning.classList.remove('active');
            }, 2000);
        }

        function updateBoss() {
            if (!currentBoss || !currentBoss.active) return;

            const boss = currentBoss;
            boss.attackTimer--;

            if (boss.name === 'SPERRING') {
                updateSperring(boss);
            } else if (boss.name === 'SYDNEY') {
                updateSydney(boss);
            } else if (boss.name === 'NULL POINTER') {
                updateNullPointer(boss);
            } else if (boss.name === 'INFINITE LOOP') {
                updateInfiniteLoop(boss);
            } else if (boss.name === 'DARK RAANMAN') {
                updateDarkRaanman(boss);
            }

            // Check if defeated
            if (boss.health <= 0 && !boss.defeated) {
                defeatBoss(boss);
            }
        }

        // Sperring barks - things he shouts during the fight
        const sperringBarks = {
            spawn: [
                '"SPERRING SMASH PUNY MAN!"',
                '"UGGA BUGGA! WHO DARE ENTER?!"',
                '"MUSTACHE GROW STRONG! YOU GROW WEAK!"',
                '"SPERRING IS HERE! TREMBLE!"',
            ],
            flex: [
                '"FLEX! UGGGHHHH! MAXIMUM POWER!"',
                '"THESE GAINS FROM LIFTING BOULDERS!"',
                '"MUSCLES BIGGER THAN YOUR HEAD!"',
                '"YOU CANNOT OUT-FLEX SPERRING!"',
                '"UNNNNGH! FEEL THE EARTH SHAKE!"',
                '"EVERY DAY IS ARM DAY! UGGA!"',
                '"PEAK CAVEMAN PERFORMANCE!"',
            ],
            mustache: [
                '"TASTE THE MUSTACHE OF DOOM!"',
                '"HANDLEBAR BARRAGE! UGGA!"',
                '"MUSTACHE IS MIGHTIEST WEAPON!"',
                '"HAIR ATTACK! YOU NO DODGE THIS!"',
                '"\'STACHE FURY! BUGGA BUGGA!"',
            ],
            slam: [
                '"GROUND GO BOOM! UGGA BUGGA!"',
                '"SLAAAAM! EARTH OBEY SPERRING!"',
                '"SPERRING COME DOWN LIKE METEOR!"',
                '"GRAVITY IS SPERRING FRIEND!"',
                '"SEISMIC STOMP! FEEL THAT?!"',
            ],
            hit: [
                '"HAH! PUNY MAN FELT THAT!"',
                '"THAT WHAT YOU GET! UGGA!"',
                '"SPERRING TOO STRONG FOR YOU!"',
            ],
            damaged: [
                '"OOF! ...THAT ACTUALLY HURT?!"',
                '"YOU THINK SCRATCH STOP SPERRING?!"',
                '"MUSTACHE ABSORB THE PAIN! UGGA!"',
                '"LUCKY HIT! NO MORE LUCKY!"',
                '"SPERRING SMASH YOU HARDER NOW!"',
            ],
            lowHealth: [
                '"SPERRING... NOT... DONE... FLEXING..."',
                '"UGGA... BUGGA... *wheeze*..."',
                '"THE MUSTACHE... IT WEAKENS..."',
                '"YOU NO SEE FINAL FORM YET!"',
            ]
        };

        // Boss bark state
        let bossBark = { text: '', timer: 0, opacity: 1 };

        function showBossBark(category) {
            const barks = sperringBarks[category];
            if (!barks || barks.length === 0) return;
            bossBark.text = barks[Math.floor(Math.random() * barks.length)];
            bossBark.timer = 120; // ~2 seconds at 60fps
            bossBark.opacity = 1;
        }

        function updateSperring(boss) {
            // Sperring flexes at things - creating shockwaves
            boss.flexPower = Math.sin(time * 0.1) * 0.5 + 0.5;

            // Spawn bark (only once)
            if (!boss.hasBarked) {
                boss.hasBarked = true;
                showBossBark('spawn');
            }

            // Low health barks
            if (boss.health <= boss.maxHealth * 0.25 && !boss.lowHealthBarked) {
                boss.lowHealthBarked = true;
                showBossBark('lowHealth');
            }

            // Move toward player
            const dx = raanman.x - boss.x;
            boss.x += Math.sign(dx) * 1.5;

            // Keep on ground
            boss.y = 350;

            // Attack patterns
            if (boss.attackTimer <= 0) {
                boss.phase = (boss.phase + 1) % 3;

                if (boss.phase === 0) {
                    // Flex shockwave
                    createFlexShockwave(boss);
                    boss.attackTimer = 90;
                    if (bossBark.timer <= 0) showBossBark('flex');
                } else if (boss.phase === 1) {
                    // Mustache projectiles
                    for (let i = -2; i <= 2; i++) {
                        projectiles.push({
                            x: boss.x,
                            y: boss.y - 40,
                            vx: i * 3,
                            vy: -8,
                            size: 15,
                            type: 'mustache',
                            color: '#8B4513'
                        });
                    }
                    boss.attackTimer = 60;
                    if (bossBark.timer <= 0) showBossBark('mustache');
                } else {
                    // Jump slam
                    boss.vy = -20;
                    boss.attackTimer = 120;
                    if (bossBark.timer <= 0) showBossBark('slam');
                }

                screenShake = 10;
            }

            // Gravity for jump
            if (boss.vy) {
                boss.vy += 0.8;
                boss.y += boss.vy;
                if (boss.y >= 350) {
                    boss.y = 350;
                    boss.vy = 0;
                    screenShake = 15;
                    createParticles(boss.x, boss.y + 50, 'landing', 20);
                }
            }
        }

        function updateSydney(boss) {
            // Sydney drives a BMW M50 into things

            if (boss.attackTimer <= 0) {
                boss.phase = (boss.phase + 1) % 2;

                if (boss.phase === 0) {
                    // Charge attack
                    boss.chargeSpeed = raanman.x > boss.x ? 15 : -15;
                    boss.attackTimer = 180;
                } else {
                    // Drop IKEA furniture
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            projectiles.push({
                                x: raanman.x + randomRange(-100, 100),
                                y: -50,
                                vx: 0,
                                vy: 5,
                                size: 40,
                                type: 'ikea',
                                color: '#0051ba'
                            });
                        }, i * 300);
                    }
                    boss.attackTimer = 120;
                }
            }

            // Apply charge
            if (boss.chargeSpeed !== 0) {
                boss.x += boss.chargeSpeed;
                createParticles(boss.x - Math.sign(boss.chargeSpeed) * 60, boss.y, 'boss', 2);

                // Decelerate
                boss.chargeSpeed *= 0.98;
                if (Math.abs(boss.chargeSpeed) < 0.5) boss.chargeSpeed = 0;
            }

            // Keep in bounds
            boss.x = clamp(boss.x, cameraX + 100, cameraX + canvas.width - 100);
            boss.y = 420;
        }

        function createFlexShockwave(boss) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i / 12);
                projectiles.push({
                    x: boss.x,
                    y: boss.y - 20,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    size: 20,
                    type: 'flex',
                    color: '#ff8800',
                    life: 60
                });
            }
            createParticles(boss.x, boss.y - 20, 'boss', 30);
        }

        // NULL POINTER - Teleports and throws exceptions
        function updateNullPointer(boss) {
            if (boss.teleportCooldown > 0) boss.teleportCooldown--;

            // Teleport randomly
            if (boss.attackTimer <= 0) {
                boss.phase = (boss.phase + 1) % 3;

                if (boss.phase === 0 && boss.teleportCooldown <= 0) {
                    // Teleport behind player
                    createParticles(boss.x, boss.y, 'glitch', 30);
                    boss.x = raanman.x + (raanman.facingRight ? -150 : 150);
                    boss.y = 350;
                    createParticles(boss.x, boss.y, 'glitch', 30);
                    screenShake = 15;
                    boss.teleportCooldown = 60;
                    boss.attackTimer = 45;
                } else if (boss.phase === 1) {
                    // Throw null pointer exceptions
                    for (let i = 0; i < 5; i++) {
                        projectiles.push({
                            x: boss.x,
                            y: boss.y - 40,
                            vx: randomRange(-8, 8),
                            vy: randomRange(-10, -5),
                            size: 12,
                            type: 'exception',
                            color: '#aa00ff',
                            text: 'null'
                        });
                    }
                    boss.attackTimer = 60;
                } else {
                    // Corruption wave
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i / 8);
                        projectiles.push({
                            x: boss.x,
                            y: boss.y - 30,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            size: 15,
                            type: 'corruption',
                            color: '#aa00ff',
                            life: 90
                        });
                    }
                    boss.attackTimer = 90;
                }
            }

            boss.x = clamp(boss.x, cameraX + 50, cameraX + canvas.width - 50);
        }

        // INFINITE LOOP - Creates clones of itself
        function updateInfiniteLoop(boss) {
            // Update clones
            boss.clones = boss.clones || [];
            boss.clones.forEach(clone => {
                clone.x += clone.vx;
                clone.y += clone.vy;
                clone.vy += 0.3;
                clone.life--;

                // Clone attacks player
                if (clone.life > 0) {
                    const dx = raanman.x - clone.x;
                    const dy = raanman.y - clone.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 40 && raanman.invincible <= 0) {
                        takeDamage(15);
                    }
                }
            });
            boss.clones = boss.clones.filter(c => c.life > 0 && c.y < canvas.height);

            // Spinning motion
            const angle = time * 0.05;
            const centerX = raanman.x + Math.cos(angle) * 200;
            boss.x = lerp(boss.x, centerX, 0.02);
            boss.y = 300 + Math.sin(time * 0.08) * 50;

            if (boss.attackTimer <= 0) {
                boss.phase = (boss.phase + 1) % 3;

                if (boss.phase === 0) {
                    // Spawn clones
                    for (let i = 0; i < 3; i++) {
                        boss.clones.push({
                            x: boss.x,
                            y: boss.y,
                            vx: randomRange(-6, 6),
                            vy: randomRange(-10, -5),
                            life: 120
                        });
                    }
                    createParticles(boss.x, boss.y, 'glitch', 20);
                    boss.attackTimer = 90;
                } else if (boss.phase === 1) {
                    // Recursive projectiles (spiral pattern)
                    for (let i = 0; i < 16; i++) {
                        const a = (Math.PI * 2 * i / 16) + time * 0.1;
                        projectiles.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(a) * 5,
                            vy: Math.sin(a) * 5,
                            size: 10,
                            type: 'loop',
                            color: '#00ffaa',
                            life: 120
                        });
                    }
                    boss.attackTimer = 75;
                } else {
                    // While(true) beam
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            projectiles.push({
                                x: boss.x,
                                y: boss.y,
                                vx: (raanman.x - boss.x) / 30,
                                vy: (raanman.y - boss.y) / 30,
                                size: 8,
                                type: 'loop',
                                color: '#00ffaa',
                                life: 90
                            });
                        }, i * 50);
                    }
                    boss.attackTimer = 150;
                }
            }

            boss.x = clamp(boss.x, cameraX + 50, cameraX + canvas.width - 50);
        }

        // DARK RAANMAN - The ultimate nemesis, mirrors player abilities
        function updateDarkRaanman(boss) {
            // Dark Raanman moves like the player but inverted
            const dx = raanman.x - boss.x;
            const dy = raanman.y - boss.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Gravity and movement
            boss.vy = boss.vy || 0;
            boss.vx = boss.vx || 0;
            boss.vy += 0.8;

            // Mirror player movement with prediction
            if (dist > 150) {
                boss.vx = lerp(boss.vx, Math.sign(dx) * 5, 0.1);
            } else if (dist < 100) {
                boss.vx = lerp(boss.vx, -Math.sign(dx) * 3, 0.1);
            }

            // Jump when player jumps or to reach player
            if (boss.y >= 400 && (raanman.vy < -5 || Math.random() < 0.02)) {
                boss.vy = -15;
                createParticles(boss.x, boss.y, 'damage', 15);
            }

            boss.x += boss.vx;
            boss.y += boss.vy;

            // Keep on screen and on ground
            if (boss.y > 400) {
                boss.y = 400;
                boss.vy = 0;
            }
            boss.x = clamp(boss.x, cameraX + 50, cameraX + canvas.width - 50);
            boss.facingRight = dx > 0;

            if (boss.attackTimer <= 0) {
                boss.phase = (boss.phase + 1) % 4;

                if (boss.phase === 0) {
                    // ANTI-HACK - creates TODO blocks
                    for (let i = 0; i < 3; i++) {
                        spawnTodoBlock(
                            raanman.x + randomRange(-200, 200),
                            randomRange(280, 380)
                        );
                    }
                    createParticles(boss.x, boss.y - 22, 'damage', 25);
                    screenShake = 10;
                    boss.attackTimer = 120;
                } else if (boss.phase === 1) {
                    // Dark HACK wave
                    boss.isHacking = true;
                    createParticleBurst(boss.x, boss.y - 22, 'hack', 40, 'explosion');
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 * i / 12);
                        projectiles.push({
                            x: boss.x,
                            y: boss.y - 22,
                            vx: Math.cos(angle) * 8,
                            vy: Math.sin(angle) * 8,
                            size: 15,
                            type: 'darkhack',
                            color: '#ff0055',
                            life: 60
                        });
                    }
                    screenShake = 20;
                    glitchIntensity = 0.8;
                    setTimeout(() => { boss.isHacking = false; }, 500);
                    boss.attackTimer = 90;
                } else if (boss.phase === 2) {
                    // Shadow dash through player
                    boss.vx = Math.sign(dx) * 20;
                    createParticles(boss.x, boss.y - 22, 'glitch', 30);
                    screenShake = 15;
                    boss.attackTimer = 60;
                } else {
                    // Summon bugs
                    for (let i = 0; i < 3; i++) {
                        const plat = platforms.find(p => p.y < 450 && p.x > cameraX && p.x < cameraX + canvas.width);
                        if (plat) {
                            spawnBug(boss.x + randomRange(-100, 100), plat.y - 15, Math.random() > 0.5 ? 1 : -1, plat);
                        }
                    }
                    boss.attackTimer = 150;
                }
            }

            // Collision with player
            if (dist < 40 && raanman.invincible <= 0) {
                takeDamage(35);
            }
        }

        function defeatBoss(boss) {
            boss.defeated = true;
            boss.active = false;
            bossesDefeated++;
            score += 2000 * combo;
            combo += 10;
            if (combo > maxCombo) maxCombo = combo;

            screenShake = 50;
            glitchIntensity = 2;
            screenFlash = { intensity: 1, color: boss.color };
            slowMotion = 0.1;
            hitstop = 20;

            // MASSIVE BOSS DEATH EXPLOSION - cascading effects
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const offsetX = randomRange(-80, 80);
                    const offsetY = randomRange(-60, 60);
                    createParticleBurst(boss.x + offsetX, boss.y + offsetY, 'boss', 60, 'explosion');
                    createParticles(boss.x + offsetX, boss.y + offsetY, 'spark', 40);
                    createParticles(boss.x + offsetX, boss.y + offsetY, 'glitch', 25);
                    screenShake = 30 - i * 2;
                    if (i % 3 === 0) {
                        screenFlash = { intensity: 0.8 - i * 0.05, color: boss.color };
                    }
                }, i * 80);
            }

            // Binary rain effect
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    createParticles(boss.x + randomRange(-100, 100), boss.y - 50, 'binary', 30);
                    createParticles(boss.x + randomRange(-100, 100), boss.y - 50, 'code', 25);
                }, i * 100);
            }

            // Final massive burst
            setTimeout(() => {
                createParticleBurst(boss.x, boss.y - 30, 'optimization', 100, 'explosion');
                createParticles(boss.x, boss.y - 30, 'star', 50);
                screenShake = 60;
                screenFlash = { intensity: 1, color: '#ffffff' };
            }, 1200);

            setTimeout(() => {
                slowMotion = 1;
                currentBoss = null;
            }, 1500);

            // Check for victory - only after Dark Raanman is defeated
            if (boss.isFinalBoss && boss.defeated) {
                setTimeout(() => victory(), 2500);
            }
        }

        function drawBoss() {
            if (!currentBoss || !currentBoss.active) return;

            const boss = currentBoss;
            const x = boss.x - cameraX;
            const y = boss.y;

            ctx.save();

            if (boss.name === 'SPERRING') {
                // Sperring - muscular guy with massive mustache
                const flex = 1 + boss.flexPower * 0.3;

                // Body
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath();
                ctx.ellipse(x, y - 30, 30 * flex, 40, 0, 0, Math.PI * 2);
                ctx.fill();

                // Muscles
                ctx.fillStyle = '#ffbb88';
                ctx.beginPath();
                ctx.ellipse(x - 35 * flex, y - 35, 20 * flex, 25, -0.3, 0, Math.PI * 2);
                ctx.ellipse(x + 35 * flex, y - 35, 20 * flex, 25, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath();
                ctx.arc(x, y - 75, 25, 0, Math.PI * 2);
                ctx.fill();

                // MAGNIFICENT MUSTACHE
                ctx.fillStyle = '#4a3728';
                ctx.beginPath();
                ctx.moveTo(x - 30, y - 70);
                ctx.quadraticCurveTo(x - 40, y - 60 - boss.flexPower * 10, x - 35, y - 55);
                ctx.quadraticCurveTo(x, y - 65, x + 35, y - 55);
                ctx.quadraticCurveTo(x + 40, y - 60 - boss.flexPower * 10, x + 30, y - 70);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 10, y - 80, 4, 0, Math.PI * 2);
                ctx.arc(x + 10, y - 80, 4, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.fillStyle = '#333';
                ctx.fillRect(x - 20, y, 15, 50);
                ctx.fillRect(x + 5, y, 15, 50);

            }

            // Boss bark speech bubble (renders for any boss with active bark)
            if (bossBark.timer > 0) {
                bossBark.timer--;
                bossBark.opacity = Math.min(1, bossBark.timer / 20);
                const barkX = x;
                const barkY = y - boss.height - 30;

                ctx.save();
                ctx.globalAlpha = bossBark.opacity;

                // Speech bubble background
                ctx.font = 'bold 13px Courier New';
                const textWidth = ctx.measureText(bossBark.text).width;
                const padding = 10;
                const bubbleW = textWidth + padding * 2;
                const bubbleH = 28;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.beginPath();
                ctx.roundRect(barkX - bubbleW/2, barkY - bubbleH/2, bubbleW, bubbleH, 6);
                ctx.fill();
                ctx.strokeStyle = boss.color || '#ff8800';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Speech bubble pointer
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.beginPath();
                ctx.moveTo(barkX - 6, barkY + bubbleH/2);
                ctx.lineTo(barkX, barkY + bubbleH/2 + 10);
                ctx.lineTo(barkX + 6, barkY + bubbleH/2);
                ctx.fill();

                // Text
                ctx.fillStyle = boss.color || '#ff8800';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(bossBark.text, barkX, barkY);

                ctx.restore();
            }

            if (boss.name === 'SYDNEY') {
                // Sydney in a BMW M50

                // Car body
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.roundRect(x - 60, y - 30, 120, 40, 5);
                ctx.fill();

                // Car top
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.roundRect(x - 35, y - 50, 70, 25, 3);
                ctx.fill();

                // Windows
                ctx.fillStyle = '#335577';
                ctx.fillRect(x - 30, y - 47, 25, 18);
                ctx.fillRect(x + 5, y - 47, 25, 18);

                // Sydney inside
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath();
                ctx.arc(x - 15, y - 40, 8, 0, Math.PI * 2);
                ctx.fill();

                // Wheels
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(x - 40, y + 10, 15, 0, Math.PI * 2);
                ctx.arc(x + 40, y + 10, 15, 0, Math.PI * 2);
                ctx.fill();

                // BMW logo
                ctx.fillStyle = '#0066cc';
                ctx.beginPath();
                ctx.arc(x, y - 15, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y - 15, 6, 0, Math.PI * 2);
                ctx.fill();

                // Exhaust particles when charging
                if (Math.abs(boss.chargeSpeed) > 1) {
                    ctx.fillStyle = '#333';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(x - Math.sign(boss.chargeSpeed) * 65 + randomRange(-10, 10),
                               y + 5 + randomRange(-5, 5),
                               randomRange(3, 8), 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (boss.name === 'NULL POINTER') {
                // Ghostly glitchy figure
                ctx.shadowColor = '#aa00ff';
                ctx.shadowBlur = 20;

                // Glitchy body
                for (let i = 0; i < 3; i++) {
                    ctx.globalAlpha = 0.3 + i * 0.2;
                    ctx.fillStyle = '#aa00ff';
                    ctx.fillRect(x - 20 + randomRange(-3, 3) * i, y - 80 + i * 5, 40, 80);
                }
                ctx.globalAlpha = 1;

                // Question mark head
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 40px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('?', x, y - 50);

                // Floating "null" text
                ctx.fillStyle = '#aa00ff88';
                ctx.font = '12px Courier New';
                ctx.fillText('null', x + Math.sin(time * 0.1) * 20, y - 90);
                ctx.fillText('undefined', x + Math.cos(time * 0.15) * 30, y - 100);

                ctx.shadowBlur = 0;

            } else if (boss.name === 'INFINITE LOOP') {
                // Spinning recursive pattern
                ctx.shadowColor = '#00ffaa';
                ctx.shadowBlur = 15;

                // Recursive circles
                for (let i = 0; i < 5; i++) {
                    const angle = time * 0.1 + (i * Math.PI * 2 / 5);
                    const dist = 20 + i * 8;
                    ctx.globalAlpha = 0.8 - i * 0.12;
                    ctx.fillStyle = '#00ffaa';
                    ctx.beginPath();
                    ctx.arc(x + Math.cos(angle) * dist, y - 35 + Math.sin(angle) * dist, 15 - i * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Center core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y - 35, 20, 0, Math.PI * 2);
                ctx.fill();

                // Infinity symbol
                ctx.strokeStyle = '#00ffaa';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - 10, y - 35);
                ctx.bezierCurveTo(x - 10, y - 45, x + 10, y - 25, x + 10, y - 35);
                ctx.bezierCurveTo(x + 10, y - 45, x - 10, y - 25, x - 10, y - 35);
                ctx.stroke();

                // Draw clones
                (boss.clones || []).forEach(clone => {
                    ctx.globalAlpha = clone.life / 120;
                    ctx.fillStyle = '#00ffaa';
                    ctx.beginPath();
                    ctx.arc(clone.x - cameraX, clone.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

            } else if (boss.name === 'DARK RAANMAN') {
                // The anti-Raanman - inverted colors, evil aura
                ctx.shadowColor = '#ff0055';
                ctx.shadowBlur = 30;

                // Evil aura
                const auraSize = 40 + Math.sin(time * 0.15) * 10;
                const gradient = ctx.createRadialGradient(x + 15, y - 22, 0, x + 15, y - 22, auraSize);
                gradient.addColorStop(0, 'rgba(255, 0, 85, 0)');
                gradient.addColorStop(0.7, 'rgba(255, 0, 85, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 0, 85, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + 15, y - 22, auraSize, 0, Math.PI * 2);
                ctx.fill();

                // Glitch duplicates when hacking
                if (boss.isHacking) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#00ffff';
                    drawDarkRaanmanBody(x - 3, y);
                    ctx.fillStyle = '#ffff00';
                    drawDarkRaanmanBody(x + 3, y);
                    ctx.globalAlpha = 1;
                }

                drawDarkRaanmanBody(x, y);
                ctx.shadowBlur = 0;
            }

            // Health bar
            ctx.fillStyle = '#333';
            ctx.fillRect(x - 50, y - 110, 100, 10);
            ctx.fillStyle = boss.color;
            ctx.fillRect(x - 50, y - 110, (boss.health / boss.maxHealth) * 100, 10);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(x - 50, y - 110, 100, 10);

            // Name
            ctx.fillStyle = boss.color;
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(boss.name, x, y - 120);
            ctx.fillStyle = '#888';
            ctx.font = '10px Courier New';
            ctx.fillText(boss.subtitle, x, y - 95);

            ctx.restore();
        }

        // ============================================
        // PROJECTILE SYSTEM
        // ============================================
        const _tOffsets = [101,109,116,100,117,79,103,82,86,111,105,118];
        function updateProjectiles() {
            projectiles = projectiles.filter(p => {
                p.x += p.vx * slowMotion;
                p.y += p.vy * slowMotion;

                if (p.type !== 'flex') {
                    p.vy += 0.3 * slowMotion;
                }

                if (p.life !== undefined) {
                    p.life -= slowMotion;
                    if (p.life <= 0) return false;
                }

                // Check collision with Raanman
                if (raanman.invincible <= 0) {
                    const dx = raanman.x + 15 - p.x;
                    const dy = raanman.y - 22 - p.y;
                    if (Math.sqrt(dx*dx + dy*dy) < p.size + 15) {
                        takeDamage(20);
                        return false;
                    }
                }

                // Remove if off screen
                return p.y < canvas.height + 100 && p.x > cameraX - 100 && p.x < cameraX + canvas.width + 100;
            });
        }

        function drawProjectiles() {
            projectiles.forEach(p => {
                const x = p.x - cameraX;
                ctx.save();

                if (p.type === 'mustache') {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.moveTo(x - 10, p.y);
                    ctx.quadraticCurveTo(x, p.y - 8, x + 10, p.y);
                    ctx.quadraticCurveTo(x, p.y + 5, x - 10, p.y);
                    ctx.fill();
                } else if (p.type === 'ikea') {
                    // IKEA furniture
                    ctx.fillStyle = p.color;
                    ctx.fillRect(x - 20, p.y - 15, 40, 30);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('IKEA', x, p.y + 3);
                } else if (p.type === 'flex') {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 60;
                    ctx.beginPath();
                    ctx.arc(x, p.y, p.size * (1 - p.life/60) + 5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(x, p.y, p.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // ============================================
        // RAANMAN UPDATE & DRAW
        // ============================================
        function updateRaanman() {
            if (hitstop > 0) {
                hitstop -= deltaTime;
                return;
            }

            // Horizontal movement (frame-rate independent)
            const lerpFactor = 1 - Math.pow(0.7, deltaTime);
            const frictionFactor = Math.pow(0.85, deltaTime);

            if (keys.left) {
                raanman.vx = lerp(raanman.vx, -raanman.speed, lerpFactor);
                raanman.facingRight = false;
            } else if (keys.right) {
                raanman.vx = lerp(raanman.vx, raanman.speed, lerpFactor);
                raanman.facingRight = true;
            } else {
                raanman.vx *= frictionFactor;
            }

            // Jumping - MAXIMUM JUICE
            if (keys.jump && !jumpPressed && raanman.jumpsLeft > 0) {
                raanman.vy = raanman.jumpForce;
                raanman.jumpsLeft--;
                jumpPressed = true;
                raanman.squash = 0.5;
                raanman.stretch = 1.5;
                createParticles(raanman.x + 15, raanman.y, 'jump', 20);
                createParticles(raanman.x + 15, raanman.y, 'smoke', 8);
                createParticles(raanman.x + 15, raanman.y + 20, 'spark', 5);
                screenShake = 5;

                if (raanman.jumpsLeft === 0) {
                    // DOUBLE JUMP - extra juice!
                    createParticleBurst(raanman.x + 15, raanman.y, 'optimization', 30, 'ring');
                    createParticles(raanman.x + 15, raanman.y, 'glitch', 15);
                    createParticles(raanman.x + 15, raanman.y, 'spark', 25);
                    createParticles(raanman.x + 15, raanman.y, 'spark', 8);
                    screenFlash = { intensity: 0.5, color: '#00ff88' };
                    screenShake = 10;
                    glitchIntensity = 0.3;
                }
            }
            if (!keys.jump) jumpPressed = false;

            // HACK ability
            if (keys.hack && !hackPressed && hackMeter >= 100 && raanman.hackCooldown <= 0) {
                activateHack();
                hackPressed = true;
            }
            if (!keys.hack) hackPressed = false;

            // Hack duration
            if (raanman.hackDuration > 0) {
                raanman.hackDuration--;
                raanman.isHacking = true;
                glitchIntensity = 0.5;
            } else {
                raanman.isHacking = false;
            }

            // Gravity (frame-rate independent)
            raanman.vy += raanman.gravity * slowMotion * deltaTime;
            raanman.vy = clamp(raanman.vy, -25, 25);

            // Apply velocity (frame-rate independent)
            raanman.x += raanman.vx * slowMotion * deltaTime;
            raanman.y += raanman.vy * slowMotion * deltaTime;

            // Squash and stretch recovery
            const squashLerp = 1 - Math.pow(0.8, deltaTime);
            raanman.squash = lerp(raanman.squash, 1, squashLerp);
            raanman.stretch = lerp(raanman.stretch, 1, squashLerp);

            // Platform collision
            raanman.grounded = false;
            platforms.forEach(p => {
                if (raanman.x + raanman.width > p.x &&
                    raanman.x < p.x + p.width &&
                    raanman.y > p.y &&
                    raanman.y - raanman.height < p.y + p.height &&
                    raanman.vy > 0) {

                    // Land on platform - IMPACTFUL
                    if (raanman.vy > 5) {
                        const impactForce = raanman.vy / 10;
                        createParticles(raanman.x + 15, p.y, 'landing', 15 + impactForce * 5);
                        createParticles(raanman.x + 15, p.y, 'smoke', 10);
                        if (raanman.vy > 12) {
                            createParticles(raanman.x + 15, p.y, 'spark', 12);
                        }
                        screenShake = raanman.vy / 3;
                        raanman.squash = 1.4;
                        raanman.stretch = 0.6;
                    }

                    raanman.y = p.y;
                    raanman.vy = 0;
                    raanman.grounded = true;
                    raanman.jumpsLeft = raanman.maxJumps;
                }
            });

            // Fall death
            if (raanman.y > canvas.height + 200) {
                takeDamage(100);
            }

            // Invincibility frames
            if (raanman.invincible > 0) raanman.invincible--;

            // Hack cooldown
            if (raanman.hackCooldown > 0) raanman.hackCooldown--;

            // Trail - more particles when moving fast
            if (Math.abs(raanman.vx) > 1 || Math.abs(raanman.vy) > 1) {
                raanman.trail.push({ x: raanman.x + 15, y: raanman.y - 22, alpha: 1 });
                // Spawn trail particles based on speed
                const speed = Math.sqrt(raanman.vx * raanman.vx + raanman.vy * raanman.vy);
                if (speed > 4 && Math.random() > 0.5) {
                    createTrailParticle(raanman.x + 15 + randomRange(-5, 5), raanman.y - 22 + randomRange(-5, 5), combo > 5 ? '#ff00ff' : '#00ff88');
                }
                if (speed > 8 && Math.random() > 0.7) {
                    createParticles(raanman.x + 15, raanman.y - 22, 'spark', 2);
                }
            }
            raanman.trail = raanman.trail.filter(t => {
                t.alpha -= 0.08;
                return t.alpha > 0;
            });

            // Glitch offset when hacking
            if (raanman.isHacking) {
                raanman.glitchOffset.x = randomRange(-4, 4);
                raanman.glitchOffset.y = randomRange(-4, 4);
            } else {
                raanman.glitchOffset.x = lerp(raanman.glitchOffset.x, 0, 0.3);
                raanman.glitchOffset.y = lerp(raanman.glitchOffset.y, 0, 0.3);
            }

            // Camera follow
            cameraTargetX = raanman.x - 250;
            if (cameraTargetX < 0) cameraTargetX = 0;
            cameraX = lerp(cameraX, cameraTargetX, 0.08);

            // Level progress for boss spawning
            levelProgress = raanman.x;

            // Spawn bosses at certain progress points
            // Spawn boss based on level config
            const config = typeof getLevelConfig === 'function' ? getLevelConfig() : { bossAt: 2000, boss: 'sperring' };
            const bossKey = config.boss;
            if (bosses[bossKey] && levelProgress > config.bossAt && !bosses[bossKey].active && !bosses[bossKey].defeated) {
                spawnBoss(bossKey);
            }
        }

        function drawRaanman() {
            const x = raanman.x - cameraX + raanman.glitchOffset.x;
            const y = raanman.y + raanman.glitchOffset.y;

            ctx.save();

            // Trail
            raanman.trail.forEach(t => {
                ctx.globalAlpha = t.alpha * 0.4;
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(t.x - cameraX, t.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Invincibility flicker
            if (raanman.invincible > 0 && Math.floor(time / 3) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // Glitch duplicates when hacking
            if (raanman.isHacking) {
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#ff00ff';
                drawRaanmanBody(x - 3, y, raanman.squash, raanman.stretch);
                ctx.fillStyle = '#00ffff';
                drawRaanmanBody(x + 3, y, raanman.squash, raanman.stretch);
                ctx.globalAlpha = 1;
            }

            drawRaanmanBody(x, y, raanman.squash, raanman.stretch);

            // Optimization aura when combo is high
            if (combo > 3) {
                const auraSize = 30 + Math.sin(time * 0.15) * 8;
                const gradient = ctx.createRadialGradient(x + 15, y - 22, 0, x + 15, y - 22, auraSize);
                gradient.addColorStop(0, 'rgba(0, 255, 136, 0)');
                gradient.addColorStop(0.7, `rgba(0, 255, 136, ${0.1 + combo * 0.02})`);
                gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + 15, y - 22, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawRaanmanBody(x, y, squash, stretch) {
            ctx.save();
            ctx.translate(x + 15, y);
            ctx.scale(squash, stretch);
            ctx.translate(-(x + 15), -y);

            // Black turtleneck body
            ctx.fillStyle = '#111';
            ctx.fillRect(x + 5, y - 30, 20, 25);

            // Turtleneck collar
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 3, y - 32, 24, 8);

            // Bald head - devastatingly smooth
            ctx.fillStyle = '#ffdbac';
            ctx.shadowColor = '#ffdbac';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(x + 15, y - 38, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Tiny sunglasses - impossibly small
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 7, y - 40, 6, 3);
            ctx.fillRect(x + 17, y - 40, 6, 3);
            ctx.fillRect(x + 13, y - 39, 4, 1);

            // Reflection on glasses
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x + 8, y - 40, 2, 1);
            ctx.fillRect(x + 18, y - 40, 2, 1);

            // Slight smirk
            ctx.strokeStyle = '#995533';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x + 15, y - 33, 4, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Legs with animation
            ctx.fillStyle = '#222';
            const legOffset = raanman.grounded ? Math.sin(time * 0.3) * (Math.abs(raanman.vx) > 1 ? 3 : 0) : 0;
            ctx.fillRect(x + 7, y - 5 - legOffset, 6, 10);
            ctx.fillRect(x + 17, y - 5 + legOffset, 6, 10);

            ctx.restore();
        }

        // Dark Raanman body - inverted evil version
        function drawDarkRaanmanBody(x, y) {
            // Dark turtleneck body - blood red
            ctx.fillStyle = '#330000';
            ctx.fillRect(x + 5, y - 30, 20, 25);

            // Collar
            ctx.fillStyle = '#440000';
            ctx.fillRect(x + 3, y - 32, 24, 8);

            // Head - pale and sinister
            ctx.fillStyle = '#aaaacc';
            ctx.shadowColor = '#ff0055';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(x + 15, y - 38, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Evil sunglasses - red lenses
            ctx.fillStyle = '#ff0055';
            ctx.fillRect(x + 7, y - 40, 6, 3);
            ctx.fillRect(x + 17, y - 40, 6, 3);
            ctx.fillRect(x + 13, y - 39, 4, 1);

            // Evil glow on glasses
            ctx.fillStyle = 'rgba(255, 0, 85, 0.5)';
            ctx.fillRect(x + 8, y - 40, 2, 1);
            ctx.fillRect(x + 18, y - 40, 2, 1);

            // Evil frown
            ctx.strokeStyle = '#ff0055';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x + 15, y - 30, 4, Math.PI + 0.2, -0.2);
            ctx.stroke();

            // Legs
            ctx.fillStyle = '#220000';
            ctx.fillRect(x + 7, y - 5, 6, 10);
            ctx.fillRect(x + 17, y - 5, 6, 10);

            // "DR" label
            ctx.fillStyle = '#ff0055';
            ctx.font = 'bold 8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('DR', x + 15, y - 18);
        }

        // ============================================
        // HACK ABILITY - REALITY DELETION
        // ============================================
        function activateHack() {
            raanman.isHacking = true;
            raanman.hackDuration = 45;
            raanman.hackCooldown = 60;
            hackMeter = 0;
            screenShake = 35;
            glitchIntensity = 1.5;
            screenFlash = { intensity: 0.8, color: '#ff00ff' };
            slowMotion = 0.2;
            hitstop = 10;

            // MASSIVE particle burst from Raanman
            createParticleBurst(raanman.x + 15, raanman.y - 22, 'hack', 50, 'explosion');
            createParticles(raanman.x + 15, raanman.y - 22, 'glitch', 40);
            createParticles(raanman.x + 15, raanman.y - 22, 'binary', 30);
            createParticles(raanman.x + 15, raanman.y - 22, 'code', 25);

            // Spreading hack wave effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticles(raanman.x + 15 + (i - 2) * 80, raanman.y - 22, 'glitch', 15);
                }, i * 50);
            }

            setTimeout(() => { slowMotion = 1; }, 400);

            // Delete all visible TODO blocks with EXTREME effects
            let deletedAny = false;
            let deleteDelay = 0;
            todoBlocks.forEach(t => {
                if (!t.deleted && Math.abs(t.x - raanman.x) < 600) {
                    // Stagger deletions for dramatic effect
                    setTimeout(() => {
                        t.deleted = true;
                        todosDeleted++;
                        score += 100 * combo;
                        combo++;
                        if (combo > maxCombo) maxCombo = combo;

                        // MASSIVE particle explosion on each TODO
                        createParticleBurst(t.x + t.width/2, t.y + t.height/2, 'hack', 60, 'explosion');
                        createParticles(t.x + t.width/2, t.y + t.height/2, 'code', 40);
                        createParticles(t.x + t.width/2, t.y + t.height/2, 'glitch', 25);
                        createParticles(t.x + t.width/2, t.y + t.height/2, 'spark', 30);
                        createParticles(t.x + t.width/2, t.y + t.height/2, 'rust', 20);

                        screenShake = 20;
                        screenFlash = { intensity: 0.4, color: '#ff00ff' };
                    }, deleteDelay);
                    deleteDelay += 80;
                    deletedAny = true;
                }
            });

            // Damage boss if active - with EXTRA JUICE
            if (currentBoss && currentBoss.active) {
                const dist = Math.abs(currentBoss.x - raanman.x);
                if (dist < 500) {
                    currentBoss.health -= 30;
                    score += 250 * combo;

                    // Boss bark on taking damage
                    if (currentBoss.name === 'SPERRING' && bossBark.timer <= 0) {
                        showBossBark('damaged');
                    }

                    // Boss damage explosion
                    createParticleBurst(currentBoss.x, currentBoss.y - 30, 'boss', 80, 'explosion');
                    createParticles(currentBoss.x, currentBoss.y - 30, 'hack', 50);
                    createParticles(currentBoss.x, currentBoss.y - 30, 'spark', 40);
                    createParticles(currentBoss.x, currentBoss.y - 30, 'glitch', 30);

                    screenShake = 40;
                    hitstop = 15;
                    slowMotion = 0.1;
                    setTimeout(() => { slowMotion = 1; }, 500);
                }
            }

            // Spawn new TODOs ahead
            if (deletedAny) {
                setTimeout(() => {
                    for (let i = 0; i < 3; i++) {
                        spawnTodoBlock(
                            raanman.x + 800 + Math.random() * 600,
                            260 + Math.random() * 140
                        );
                    }
                }, 2000);
            }
        }

        // ============================================
        // DAMAGE & HEALTH
        // ============================================
        function takeDamage(amount) {
            if (raanman.invincible > 0) return;

            health -= amount;
            combo = 1;
            raanman.invincible = 90;
            screenShake = 25;
            screenFlash = { intensity: 0.7, color: '#ff0055' };
            hitstop = 12;
            glitchIntensity = 0.8;

            // PAINFUL particle effects
            createParticleBurst(raanman.x + 15, raanman.y - 22, 'hack', 40, 'explosion');
            createParticles(raanman.x + 15, raanman.y - 22, 'damage', 35);
            createParticles(raanman.x + 15, raanman.y - 22, 'spark', 25);
            createParticles(raanman.x + 15, raanman.y - 22, 'glitch', 20);

            // Knockback
            raanman.vx = raanman.facingRight ? -8 : 8;
            raanman.vy = -10;

            if (health <= 0) {
                gameOver();
            }
        }

        // ============================================
        // COLLISION DETECTION
        // ============================================
        function checkCollisions() {
            // Fragment collection
            fragments.forEach(f => {
                if (f.collected) return;

                const dx = (raanman.x + 15) - f.x;
                const dy = (raanman.y - 22) - f.baseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 40) {
                    f.collected = true;
                    const points = f.type === 'super' ? 200 : 50;
                    score += points * combo;
                    combo++;
                    if (combo > maxCombo) maxCombo = combo;
                    hackMeter = Math.min(100, hackMeter + (f.type === 'super' ? 60 : 25));
                    optimizationsCollected++;

                    // JUICY COLLECTION EFFECTS
                    if (f.type === 'super') {
                        // SUPER fragment - massive effects
                        createParticleBurst(f.x, f.baseY, 'optimization', 50, 'explosion');
                        createParticles(f.x, f.baseY, 'collect', 40);
                        createParticles(f.x, f.baseY, 'star', 30);
                        createParticles(f.x, f.baseY, 'spark', 25);
                        createParticles(f.x, f.baseY, 'code', 20);
                        screenShake = 15;
                        screenFlash = { intensity: 0.5, color: '#ffff00' };
                        glitchIntensity = 0.4;
                        hitstop = 5;
                        slowMotion = 0.5;
                        setTimeout(() => { slowMotion = 1; }, 150);
                    } else {
                        // Normal fragment - still satisfying
                        createParticles(f.x, f.baseY, 'collect', 25);
                        createParticles(f.x, f.baseY, 'star', 15);
                        createParticles(f.x, f.baseY, 'spark', 10);
                        screenShake = 6;
                        screenFlash = { intensity: 0.25, color: '#00ff88' };
                    }

                    // Spawn new fragment ahead
                    setTimeout(() => {
                        spawnFragment(
                            raanman.x + 600 + Math.random() * 400,
                            180 + Math.random() * 180
                        );
                    }, 500);
                }
            });

            // TODO block collision (damage + pushback)
            todoBlocks.forEach(t => {
                if (t.deleted) return;

                if (raanman.x + raanman.width > t.x &&
                    raanman.x < t.x + t.width &&
                    raanman.y > t.y &&
                    raanman.y - raanman.height < t.y + t.height) {

                    if (raanman.invincible <= 0) {
                        takeDamage(15);
                        t.shakeOffset = 15;
                    }
                }
            });

            // Bug collision
            bugs.forEach(b => {
                if (raanman.invincible > 0) return;

                const dx = (raanman.x + 15) - b.x;
                const dy = (raanman.y - 22) - b.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 30) {
                    takeDamage(25);
                }
            });

            // Boss collision
            if (currentBoss && currentBoss.active && raanman.invincible <= 0) {
                const dx = (raanman.x + 15) - currentBoss.x;
                const dy = (raanman.y - 22) - currentBoss.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 60) {
                    takeDamage(30);
                }
            }
        }

        // ============================================
        // UPDATE GAME ENTITIES
        // ============================================
        function updateBugs() {
            bugs.forEach(b => {
                b.x += b.vx * slowMotion;
                b.legPhase += 0.3 * slowMotion;

                // Stay on platform
                if (b.platform) {
                    if (b.x < b.platform.x + 20 || b.x > b.platform.x + b.platform.width - 20) {
                        b.vx *= -1;
                    }
                }
            });
        }

        function updateFragments() {
            fragments.forEach(f => {
                if (f.collected) return;
                f.rotation += 0.03;
                f.pulse += 0.08;
            });
        }

        function updateTodoBlocks() {
            todoBlocks.forEach(t => {
                if (t.deleted) return;
                t.glowPhase += 0.05;
                t.shakeOffset *= 0.9;
            });
        }

        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        // ============================================
        // PARALLAX BACKGROUND SHADER SYSTEM
        // ============================================

        // Pre-generated background elements for performance
        let bgStars = [];
        let bgNebulae = [];
        let bgBuildings = [];
        let bgMatrixColumns = [];
        let bgGeometry = [];
        let bgInitialized = false;

        function initParallaxBackground() {
            if (bgInitialized) return;

            // Layer 1: Deep space stars (slowest - 0.05 parallax)
            bgStars = [];
            for (let i = 0; i < 150; i++) {
                bgStars.push({
                    x: Math.random() * 2000,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random() * 0.5 + 0.3,
                    twinkleSpeed: Math.random() * 0.05 + 0.02,
                    twinkleOffset: Math.random() * Math.PI * 2
                });
            }

            // Layer 2: Nebula clouds (0.1 parallax)
            bgNebulae = [];
            for (let i = 0; i < 8; i++) {
                bgNebulae.push({
                    x: i * 300 + Math.random() * 100,
                    y: Math.random() * canvas.height * 0.7,
                    width: Math.random() * 200 + 150,
                    height: Math.random() * 100 + 80,
                    hue: Math.random() > 0.5 ? 160 : 280, // Cyan or purple
                    opacity: Math.random() * 0.06 + 0.02
                });
            }

            // Layer 3: Distant city silhouettes (0.2 parallax)
            bgBuildings = [];
            for (let i = 0; i < 40; i++) {
                const height = Math.random() * 120 + 40;
                bgBuildings.push({
                    x: i * 60 + Math.random() * 30,
                    width: Math.random() * 30 + 15,
                    height: height,
                    windows: Math.floor(height / 20),
                    windowPattern: Math.random()
                });
            }

            // Layer 4: Matrix rain columns (0.3 parallax)
            bgMatrixColumns = [];
            for (let i = 0; i < 25; i++) {
                bgMatrixColumns.push({
                    x: i * 40 + Math.random() * 20,
                    chars: [],
                    speed: Math.random() * 2 + 1,
                    length: Math.floor(Math.random() * 15) + 8
                });
                // Initialize characters
                for (let j = 0; j < bgMatrixColumns[i].length; j++) {
                    bgMatrixColumns[i].chars.push({
                        char: String.fromCharCode(0x30A0 + Math.random() * 96), // Katakana
                        y: j * 18 - Math.random() * canvas.height,
                        opacity: 1 - j / bgMatrixColumns[i].length
                    });
                }
            }

            // Layer 5: Floating geometric shapes (0.4 parallax)
            bgGeometry = [];
            for (let i = 0; i < 20; i++) {
                bgGeometry.push({
                    x: Math.random() * 1500,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 30 + 10,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    type: Math.floor(Math.random() * 4), // 0: triangle, 1: square, 2: hexagon, 3: circle
                    opacity: Math.random() * 0.15 + 0.05
                });
            }

            bgInitialized = true;
        }

        function drawParallaxLayer1_Stars() {
            // Deep space stars with twinkling
            const parallax = 0.05;
            const offsetX = cameraX * parallax;

            bgStars.forEach(star => {
                const x = ((star.x - offsetX) % (canvas.width + 200)) - 100;
                const twinkle = Math.sin(time * star.twinkleSpeed + star.twinkleOffset) * 0.3 + 0.7;
                const alpha = star.brightness * twinkle;

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();

                // Occasional bright star glow
                if (star.size > 1.5) {
                    ctx.fillStyle = `rgba(200, 220, 255, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, star.y, star.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawParallaxLayer2_Nebulae() {
            // Nebula clouds - soft glowing regions
            const parallax = 0.1;
            const offsetX = cameraX * parallax;

            bgNebulae.forEach(nebula => {
                const x = ((nebula.x - offsetX) % (canvas.width + 400)) - 200;
                const pulse = Math.sin(time * 0.01 + nebula.x * 0.01) * 0.3 + 0.7;

                const gradient = ctx.createRadialGradient(
                    x + nebula.width/2, nebula.y + nebula.height/2, 0,
                    x + nebula.width/2, nebula.y + nebula.height/2, nebula.width/2
                );
                gradient.addColorStop(0, `hsla(${nebula.hue}, 80%, 50%, ${nebula.opacity * pulse})`);
                gradient.addColorStop(0.5, `hsla(${nebula.hue}, 60%, 30%, ${nebula.opacity * 0.5 * pulse})`);
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.fillRect(x, nebula.y, nebula.width, nebula.height);
            });
        }

        function drawParallaxLayer3_City() {
            // Distant cyberpunk city silhouette
            const parallax = 0.2;
            const offsetX = cameraX * parallax;
            const baseY = canvas.height - 50;

            // City glow on horizon
            const horizonGlow = ctx.createLinearGradient(0, baseY - 150, 0, baseY);
            horizonGlow.addColorStop(0, 'transparent');
            horizonGlow.addColorStop(1, 'rgba(0, 255, 136, 0.05)');
            ctx.fillStyle = horizonGlow;
            ctx.fillRect(0, baseY - 150, canvas.width, 150);

            bgBuildings.forEach(building => {
                const x = ((building.x - offsetX) % (canvas.width + 200)) - 100;
                const y = baseY - building.height;

                // Building silhouette
                ctx.fillStyle = '#0a0a12';
                ctx.fillRect(x, y, building.width, building.height);

                // Windows
                const windowSize = 3;
                const windowSpacing = 8;
                for (let row = 0; row < building.windows; row++) {
                    for (let col = 0; col < Math.floor(building.width / windowSpacing) - 1; col++) {
                        // Random window lighting
                        const isLit = Math.sin(building.windowPattern * 100 + row * 7 + col * 13 + time * 0.001) > 0.3;
                        if (isLit) {
                            const flicker = Math.random() > 0.99 ? 0.3 : 1;
                            ctx.fillStyle = `rgba(0, 255, 136, ${0.3 * flicker})`;
                            ctx.fillRect(x + 4 + col * windowSpacing, y + 5 + row * 15, windowSize, windowSize * 1.5);
                        }
                    }
                }

                // Antenna/spire on tall buildings
                if (building.height > 120) {
                    ctx.strokeStyle = '#0a0a12';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + building.width/2, y);
                    ctx.lineTo(x + building.width/2, y - 20);
                    ctx.stroke();
                    // Blinking light
                    if (Math.sin(time * 0.05 + building.x) > 0.7) {
                        ctx.fillStyle = 'rgba(255, 0, 100, 0.8)';
                        ctx.beginPath();
                        ctx.arc(x + building.width/2, y - 20, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }

        function drawParallaxLayer4_Matrix() {
            // Matrix-style falling code
            const parallax = 0.3;
            const offsetX = cameraX * parallax;

            ctx.font = '14px Courier New';

            bgMatrixColumns.forEach(column => {
                const x = ((column.x - offsetX) % (canvas.width + 100)) - 50;

                column.chars.forEach((charObj, i) => {
                    // Update position
                    charObj.y += column.speed * deltaTime;
                    if (charObj.y > canvas.height + 20) {
                        charObj.y = -20;
                        charObj.char = String.fromCharCode(0x30A0 + Math.random() * 96);
                    }

                    // Draw character
                    const alpha = charObj.opacity * (i === 0 ? 1 : 0.4);
                    ctx.fillStyle = i === 0 ?
                        `rgba(180, 255, 200, ${alpha})` :
                        `rgba(0, 255, 136, ${alpha * 0.5})`;
                    ctx.fillText(charObj.char, x, charObj.y);
                });
            });
        }

        function drawParallaxLayer5_Geometry() {
            // Floating geometric wireframes
            const parallax = 0.4;
            const offsetX = cameraX * parallax;

            bgGeometry.forEach(geo => {
                const x = ((geo.x - offsetX) % (canvas.width + 300)) - 150;
                geo.rotation += geo.rotationSpeed * deltaTime;

                ctx.save();
                ctx.translate(x, geo.y);
                ctx.rotate(geo.rotation);
                ctx.strokeStyle = `rgba(0, 255, 136, ${geo.opacity})`;
                ctx.lineWidth = 1;

                ctx.beginPath();
                if (geo.type === 0) {
                    // Triangle
                    ctx.moveTo(0, -geo.size);
                    ctx.lineTo(geo.size * 0.866, geo.size * 0.5);
                    ctx.lineTo(-geo.size * 0.866, geo.size * 0.5);
                    ctx.closePath();
                } else if (geo.type === 1) {
                    // Square
                    ctx.rect(-geo.size/2, -geo.size/2, geo.size, geo.size);
                } else if (geo.type === 2) {
                    // Hexagon
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        const px = Math.cos(angle) * geo.size;
                        const py = Math.sin(angle) * geo.size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                } else {
                    // Circle with inner pattern
                    ctx.arc(0, 0, geo.size, 0, Math.PI * 2);
                    ctx.moveTo(geo.size * 0.5, 0);
                    ctx.arc(0, 0, geo.size * 0.5, 0, Math.PI * 2);
                }
                ctx.stroke();
                ctx.restore();
            });
        }

        function drawParallaxGrid() {
            // Enhanced parallax grid with depth
            const layers = [
                { spacing: 100, parallax: 0.15, alpha: 0.03 },
                { spacing: 50, parallax: 0.3, alpha: 0.05 },
                { spacing: 25, parallax: 0.5, alpha: 0.08 }
            ];

            layers.forEach(layer => {
                ctx.strokeStyle = `rgba(0, 255, 136, ${layer.alpha})`;
                ctx.lineWidth = 1;
                const offsetX = cameraX * layer.parallax;

                // Vertical lines
                for (let i = -1; i < canvas.width / layer.spacing + 2; i++) {
                    const x = (i * layer.spacing) - (offsetX % layer.spacing);
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                // Horizontal lines
                for (let i = 0; i < canvas.height / layer.spacing + 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * layer.spacing);
                    ctx.lineTo(canvas.width, i * layer.spacing);
                    ctx.stroke();
                }
            });
        }

        function drawBackground() {
            // Initialize parallax elements if needed
            initParallaxBackground();

            // Base gradient - deeper space feel
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#050510');
            gradient.addColorStop(0.5, '#0a0a18');
            gradient.addColorStop(1, '#0f0f20');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw parallax layers (back to front)
            // On mobile: skip matrix rain + geometry layers for performance
            drawParallaxLayer1_Stars();
            drawParallaxLayer2_Nebulae();
            drawParallaxGrid();
            drawParallaxLayer3_City();
            if (!isMobile) {
                drawParallaxLayer4_Matrix();
                drawParallaxLayer5_Geometry();
            }

            // Floating code snippets (existing, enhanced)
            ctx.fillStyle = 'rgba(0, 255, 136, 0.04)';
            ctx.font = '11px Courier New';
            const codeSnippets = [
                'function optimize() {',
                '  return perfection;',
                '}',
                'while(true) refactor();',
                'gravity.rewriteInRust();',
                'sleep = null;',
                'const reality = optimize(existence);',
                'if (code.isClean) code.optimize();',
                'async function transcend() {',
                '  await enlightenment;',
                '}'
            ];
            for (let i = 0; i < 12; i++) {
                const snippet = codeSnippets[i % codeSnippets.length];
                const parallax = 0.35 + (i % 3) * 0.1;
                const x = ((i * 200 + 50) - (cameraX * parallax)) % (canvas.width + 400) - 200;
                const y = 50 + (i * 50) % 380;
                ctx.fillText(snippet, x, y);
            }

            // Scanlines + CRT + vignette (skip on mobile for performance)
            if (!isMobile) {
                // Scanlines (subtle)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                for (let i = 0; i < canvas.height; i += 4) {
                    ctx.fillRect(0, i, canvas.width, 1);
                }

                // CRT curvature effect (subtle)
                const crtGradient = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, 0,
                    canvas.width/2, canvas.height/2, canvas.width * 0.8
                );
                crtGradient.addColorStop(0, 'rgba(0, 50, 30, 0)');
                crtGradient.addColorStop(0.8, 'rgba(0, 20, 15, 0.1)');
                crtGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = crtGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Vignette
                const vignetteGradient = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, canvas.height * 0.4,
                    canvas.width/2, canvas.height/2, canvas.height * 0.9
                );
                vignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                ctx.fillStyle = vignetteGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Glitch effect
            if (glitchIntensity > 0) {
                for (let i = 0; i < 8 * glitchIntensity; i++) {
                    const y = Math.random() * canvas.height;
                    const h = randomRange(2, 15) * glitchIntensity;
                    const offset = randomRange(-20, 20) * glitchIntensity;
                    ctx.fillStyle = Math.random() > 0.5 ?
                        `rgba(0, 255, 136, ${glitchIntensity * 0.3})` :
                        `rgba(255, 0, 255, ${glitchIntensity * 0.3})`;
                    ctx.fillRect(offset, y, canvas.width, h);
                }
                glitchIntensity *= 0.92;
            }
        }

        function drawPlatforms() {
            platforms.forEach(p => {
                if (p.x + p.width < cameraX - 100 || p.x > cameraX + canvas.width + 100) return;

                const px = p.x - cameraX;

                // Platform gradient
                const gradient = ctx.createLinearGradient(px, p.y, px, p.y + p.height);
                gradient.addColorStop(0, p.type === 'ground' ? '#2a2a4e' : '#252545');
                gradient.addColorStop(1, '#1a1a2e');
                ctx.fillStyle = gradient;
                ctx.fillRect(px, p.y, p.width, p.height);

                // Top edge glow
                ctx.strokeStyle = '#00ff8844';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(px, p.y);
                ctx.lineTo(px + p.width, p.y);
                ctx.stroke();

                // Circuit pattern
                ctx.strokeStyle = '#00ff8815';
                ctx.lineWidth = 1;
                for (let i = 0; i < p.width; i += 30) {
                    ctx.beginPath();
                    ctx.moveTo(px + i, p.y + 5);
                    ctx.lineTo(px + i + 15, p.y + 5);
                    ctx.lineTo(px + i + 15, p.y + 15);
                    ctx.stroke();
                }
            });
        }

        function drawFragments() {
            fragments.forEach(f => {
                if (f.collected) return;
                if (f.x < cameraX - 50 || f.x > cameraX + canvas.width + 50) return;

                const floatY = Math.sin(time * 0.05 + f.pulse) * 6;
                const x = f.x - cameraX;
                const y = f.baseY + floatY;
                const pulse = Math.sin(f.pulse) * 4;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(f.rotation);

                // Glow
                ctx.shadowColor = f.type === 'super' ? '#ffff00' : '#00ff88';
                ctx.shadowBlur = 20 + pulse;

                // Diamond shape
                ctx.fillStyle = f.type === 'super' ? '#ffff00' : '#00ff88';
                ctx.beginPath();
                ctx.moveTo(0, -f.size/2);
                ctx.lineTo(f.size/2, 0);
                ctx.lineTo(0, f.size/2);
                ctx.lineTo(-f.size/2, 0);
                ctx.closePath();
                ctx.fill();

                // Inner bright core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(0, -f.size/4);
                ctx.lineTo(f.size/4, 0);
                ctx.lineTo(0, f.size/4);
                ctx.lineTo(-f.size/4, 0);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }

        function drawTodoBlocks() {
            todoBlocks.forEach(t => {
                if (t.deleted) return;
                if (t.x + t.width < cameraX - 50 || t.x > cameraX + canvas.width + 50) return;

                const shake = t.shakeOffset * randomRange(-1, 1);
                const x = t.x - cameraX + shake;
                const glow = Math.sin(t.glowPhase) * 5 + 10;

                // Shadow
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fillRect(x + 5, t.y + 5, t.width, t.height);

                // Background
                ctx.fillStyle = '#2d1b1b';
                ctx.fillRect(x, t.y, t.width, t.height);

                // Border with glow
                ctx.strokeStyle = '#ff4444';
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = glow;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, t.y, t.width, t.height);
                ctx.shadowBlur = 0;

                // Text
                ctx.fillStyle = '#888888';
                ctx.font = 'bold 14px Courier New';
                ctx.fillText(t.text, x + 12, t.y + 28);

                // Warning stripes
                ctx.fillStyle = '#ff444433';
                for (let i = 0; i < t.width; i += 20) {
                    ctx.fillRect(x + i, t.y, 10, 5);
                }
            });
        }

        function drawBugs() {
            bugs.forEach(b => {
                if (b.x < cameraX - 50 || b.x > cameraX + canvas.width + 50) return;

                const x = b.x - cameraX;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(x, b.y + 15, b.width/3, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.fillStyle = '#ff0055';
                ctx.shadowColor = '#ff0055';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.ellipse(x, b.y, b.width/2, b.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Shell segments
                ctx.strokeStyle = '#cc0044';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, b.y - b.height/2);
                ctx.lineTo(x, b.y + b.height/2);
                ctx.stroke();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x - 8, b.y - 5, 6, 0, Math.PI * 2);
                ctx.arc(x + 8, b.y - 5, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#000';
                const lookDir = b.vx > 0 ? 2 : -2;
                ctx.beginPath();
                ctx.arc(x - 8 + lookDir, b.y - 5, 3, 0, Math.PI * 2);
                ctx.arc(x + 8 + lookDir, b.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.strokeStyle = '#ff0055';
                ctx.lineWidth = 2;
                for (let i = -1; i <= 1; i++) {
                    const phase = b.legPhase + i * 0.5;
                    const legY = Math.sin(phase) * 4;
                    ctx.beginPath();
                    ctx.moveTo(x + i * 12, b.y + 10);
                    ctx.lineTo(x + i * 18, b.y + 18 + legY);
                    ctx.stroke();
                }

                // Label
                ctx.fillStyle = '#ff005588';
                ctx.font = 'bold 10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('BUG', x, b.y - 22);
            });
        }

        function drawUI() {
            // Update HTML UI with total score (current + previous levels)
            scoreElement.textContent = (score + (typeof totalRunScore !== 'undefined' ? totalRunScore : 0)).toLocaleString();
            comboElement.textContent = 'x' + combo;
            comboElement.style.color = combo > 10 ? '#ff00ff' : combo > 5 ? '#ffff00' : '#888';
            comboElement.style.textShadow = combo > 5 ? `0 0 10px ${combo > 10 ? '#ff00ff' : '#ffff00'}` : 'none';

            hackElement.textContent = Math.floor(hackMeter);
            hackElement.style.color = hackMeter >= 100 ? '#00ff88' : '#ff00ff';

            // Update touch hack button visual state
            const touchHackBtn = document.getElementById('touch-hack');
            if (touchHackBtn) {
                if (hackMeter >= 100 && raanman.hackCooldown <= 0) {
                    touchHackBtn.classList.add('hack-ready');
                    touchHackBtn.textContent = 'HACK';
                } else {
                    touchHackBtn.classList.remove('hack-ready');
                    touchHackBtn.textContent = Math.floor(hackMeter) + '%';
                }
            }

            // Health bar
            const healthBars = Math.ceil((health / maxHealth) * 10);
            let healthStr = '';
            for (let i = 0; i < 10; i++) {
                healthStr += i < healthBars ? '█' : '░';
            }
            healthElement.textContent = healthStr;
            healthElement.style.color = health > 60 ? '#00ff88' : health > 30 ? '#ffff00' : '#ff0055';

            // Draw level indicator on canvas
            if (typeof currentLevel !== 'undefined' && typeof getLevelConfig === 'function') {
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(`LEVEL ${currentLevel}: ${getLevelConfig().name}`, 10, 20);

                // Draw run counter
                ctx.fillStyle = '#888';
                ctx.font = '10px Courier New';
                ctx.fillText(`RUN #${currentRun || 1}`, 10, 35);
            }
        }

        // ============================================
        // GAME STATE MANAGEMENT
        // ============================================
        const _wAmps = [102,82,118,104,114,89,87,57,70,79,46,70,67];
        function initGame() {
            score = 0;
            totalRunScore = 0;
            combo = 1;
            maxCombo = 1;
            hackMeter = 0;
            health = maxHealth;
            todosDeleted = 0;
            optimizationsCollected = 0;
            bossesDefeated = 0;
            screenShake = 0;
            glitchIntensity = 0;
            slowMotion = 1;
            hitstop = 0;
            particles = [];
            projectiles = [];
            cameraX = 0;
            levelProgress = 0;
            currentBoss = null;

            // Reset bosses
            bosses.sperring.active = false;
            bosses.sperring.defeated = false;
            bosses.sperring.health = bosses.sperring.maxHealth;
            bosses.sydney.active = false;
            bosses.sydney.defeated = false;
            bosses.sydney.health = bosses.sydney.maxHealth;

            // Reset Raanman
            raanman.x = 100;
            raanman.y = 400;
            raanman.vx = 0;
            raanman.vy = 0;
            raanman.grounded = false;
            raanman.jumpsLeft = 2;
            raanman.trail = [];
            raanman.isHacking = false;
            raanman.hackDuration = 0;
            raanman.hackCooldown = 0;
            raanman.invincible = 0;
            raanman.squash = 1;
            raanman.stretch = 1;

            generateLevel();

            // Initialize background particles
            backgroundParticles = [];
            trailParticles = [];
            initBackgroundParticles();

            gameState = 'playing';
            startOverlay.classList.remove('active');
            gameOverlay.classList.remove('active');
            victoryOverlay.classList.remove('active');
        }

        function gameOver() {
            gameState = 'gameOver';
            finalScoreElement.textContent = score.toLocaleString();
            todosDeletedElement.textContent = todosDeleted;
            maxComboElement.textContent = 'x' + maxCombo;
            optimizationsElement.textContent = optimizationsCollected;
            bossesDefeatedElement.textContent = bossesDefeated;
            gameOverlay.classList.add('active');

            // THE ICONIC DEATH YELL
            showDeathYell();

            // DRAMATIC DEATH EFFECTS
            screenShake = 60;
            glitchIntensity = 2;
            screenFlash = { intensity: 1, color: '#ff0055' };
            slowMotion = 0.1;

            // Death explosion from Raanman
            createParticleBurst(raanman.x + 15, raanman.y - 22, 'hack', 80, 'explosion');
            createParticles(raanman.x + 15, raanman.y - 22, 'damage', 60);
            createParticles(raanman.x + 15, raanman.y - 22, 'glitch', 50);
            createParticles(raanman.x + 15, raanman.y - 22, 'spark', 40);

            // Cascading death waves
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const angle = (Math.PI * 2 * i / 10);
                    const dist = 50 + i * 30;
                    createParticleBurst(
                        raanman.x + 15 + Math.cos(angle) * dist,
                        raanman.y - 22 + Math.sin(angle) * dist,
                        'damage', 30, 'explosion'
                    );
                    createParticles(
                        raanman.x + 15 + Math.cos(angle) * dist,
                        raanman.y - 22 + Math.sin(angle) * dist,
                        'glitch', 20
                    );
                    screenShake = 40 - i * 3;
                    if (i % 2 === 0) {
                        screenFlash = { intensity: 0.6 - i * 0.05, color: '#ff0055' };
                    }
                }, i * 100);
            }

            // Final static
            setTimeout(() => {
                createParticles(canvas.width/2 + cameraX, canvas.height/2, 'binary', 100);
                createParticles(canvas.width/2 + cameraX, canvas.height/2, 'code', 80);
                slowMotion = 1;
            }, 1200);

            // Save to leaderboard
            saveToLeaderboard();
        }

        function victory() {
            gameState = 'victory';
            victoryScoreElement.textContent = score.toLocaleString();
            victoryOverlay.classList.add('active');
            screenFlash = { intensity: 1, color: '#00ff88' };
            slowMotion = 0.3;

            // MASSIVE VICTORY CELEBRATION
            // Firework bursts across the screen
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const x = randomRange(50, canvas.width - 50) + cameraX;
                    const y = randomRange(50, canvas.height - 150);
                    createParticleBurst(x, y, 'optimization', 60, 'explosion');
                    createParticles(x, y, 'star', 40);
                    createParticles(x, y, 'spark', 30);
                    screenShake = 15 + Math.random() * 10;
                    if (i % 3 === 0) {
                        screenFlash = { intensity: 0.5, color: ['#00ff88', '#ff00ff', '#00ffff', '#ffff00'][i % 4] };
                    }
                }, i * 150);
            }

            // Rising optimization particles
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const x = randomRange(0, canvas.width) + cameraX;
                    createParticles(x, canvas.height, 'collect', 50);
                    createParticles(x, canvas.height, 'star', 30);
                }, i * 100);
            }

            // Binary rain celebration
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    createParticles(randomRange(0, canvas.width) + cameraX, -20, 'binary', 15);
                    createParticles(randomRange(0, canvas.width) + cameraX, -20, 'code', 10);
                }, i * 50);
            }

            // Raanman ascension glow
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createParticleBurst(raanman.x + 15, raanman.y - 22 - i * 10, 'optimization', 40, 'ring');
                    createParticles(raanman.x + 15, raanman.y - 22 - i * 10, 'glitch', 15);
                }, i * 120);
            }

            // Final celebration burst
            setTimeout(() => {
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8);
                    createParticleBurst(
                        raanman.x + 15 + Math.cos(angle) * 100,
                        raanman.y - 22 + Math.sin(angle) * 100,
                        'optimization', 80, 'explosion'
                    );
                }
                screenFlash = { intensity: 1, color: '#ffffff' };
                screenShake = 50;
                slowMotion = 1;
            }, 2500);

            // Save to leaderboard
            saveToLeaderboard();
        }

        // ============================================
        // MAIN GAME LOOP (defined later with enhanced features)
        // ============================================
        let gameLoop; // Will be defined after all systems are ready

        // ============================================
        // INPUT HANDLING
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === ' ') { keys.jump = true; e.preventDefault(); }
            if (e.key === 'e' || e.key === 'E') keys.hack = true;
            if (e.key === 't' || e.key === 'T') { e.preventDefault(); runTests(); }
            if (e.key === 'l' || e.key === 'L') { e.preventDefault(); toggleLeaderboardPopup(); }
            if (e.key === '`' || e.key === '~') { e.preventDefault(); toggleDebugOverlay(); }

            if (e.key === 'Enter') {
                if (gameState !== 'playing') {
                    initGame();
                }
            }

            // Escape closes leaderboard popup
            if (e.key === 'Escape' && leaderboardVisible) {
                toggleLeaderboardPopup();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === ' ') keys.jump = false;
            if (e.key === 'e' || e.key === 'E') keys.hack = false;
        });

        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('restartBtn').addEventListener('click', initGame);
        document.getElementById('victoryBtn').addEventListener('click', initGame);

        // ============================================
        // DEBUG OVERLAY (press ~ to toggle)
        // ============================================
        let debugOverlayVisible = false;
        let debugOverlay = null;

        function toggleDebugOverlay() {
            debugOverlayVisible = !debugOverlayVisible;
            if (!debugOverlay) {
                debugOverlay = document.createElement('div');
                debugOverlay.id = 'debugOverlay';
                debugOverlay.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: rgba(0, 0, 0, 0.9);
                    color: #0f0;
                    font-family: monospace;
                    font-size: 11px;
                    padding: 10px;
                    border: 1px solid #0f0;
                    z-index: 9999;
                    min-width: 250px;
                `;
                document.body.appendChild(debugOverlay);
            }
            debugOverlay.style.display = debugOverlayVisible ? 'block' : 'none';
            if (debugOverlayVisible) updateDebugOverlay();
        }

        function updateDebugOverlay() {
            if (!debugOverlay || !debugOverlayVisible) return;

            const canvasRect = canvas.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const screenCenterX = windowWidth / 2;
            const screenCenterY = windowHeight / 2;
            const canvasCenterX = canvasRect.left + canvasRect.width / 2;
            const canvasCenterY = canvasRect.top + canvasRect.height / 2;
            const offsetX = Math.round(canvasCenterX - screenCenterX);
            const offsetY = Math.round(canvasCenterY - screenCenterY);
            const isCentered = Math.abs(offsetX) < 5 && Math.abs(offsetY) < 5;

            const gameAspect = (BASE_WIDTH / BASE_HEIGHT).toFixed(3);
            const screenAspect = (windowWidth / windowHeight).toFixed(3);

            debugOverlay.innerHTML = `
                <div style="color: #ff0; margin-bottom: 5px;">DEBUG [~ to close]</div>
                <hr style="border-color: #333; margin: 5px 0;">
                <b>Screen:</b> ${windowWidth}x${windowHeight} (${screenAspect})<br>
                <b>Canvas internal:</b> ${canvas.width}x${canvas.height}<br>
                <b>Canvas display:</b> ${Math.round(canvasRect.width)}x${Math.round(canvasRect.height)}<br>
                <b>Game aspect:</b> ${gameAspect} (16:10)<br>
                <hr style="border-color: #333; margin: 5px 0;">
                <b>Canvas position:</b> (${Math.round(canvasRect.left)}, ${Math.round(canvasRect.top)})<br>
                <b>Canvas center:</b> (${Math.round(canvasCenterX)}, ${Math.round(canvasCenterY)})<br>
                <b>Screen center:</b> (${screenCenterX}, ${screenCenterY})<br>
                <hr style="border-color: #333; margin: 5px 0;">
                <b>Offset from center:</b> (${offsetX}, ${offsetY})<br>
                <span style="color: ${isCentered ? '#0f0' : '#f00'}; font-weight: bold;">
                    ${isCentered ? '✓ CENTERED' : '✗ NOT CENTERED (offset: ' + Math.max(Math.abs(offsetX), Math.abs(offsetY)) + 'px)'}
                </span><br>
                <hr style="border-color: #333; margin: 5px 0;">
                <b>Fullscreen:</b> ${isFullscreen || document.fullscreenElement ? 'YES' : 'NO'}<br>
                <b>Scale:</b> ${scale.toFixed(3)}<br>
                <b>FPS:</b> ${(1000 / (deltaTime * TARGET_FRAME_TIME)).toFixed(1)}<br>
            `;
        }

        // Update debug overlay periodically
        setInterval(updateDebugOverlay, 100);

        // ============================================
        // UNIT TESTS
        // ============================================
        function runTests() {
            const tests = [];
            let passed = 0;
            let failed = 0;

            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        tests.push({ name, status: 'pass' });
                        passed++;
                    } else {
                        tests.push({ name, status: 'fail', error: 'Assertion failed' });
                        failed++;
                    }
                } catch (e) {
                    tests.push({ name, status: 'fail', error: e.message });
                    failed++;
                }
            }

            // Utility function tests
            test('lerp interpolates correctly at 0', () => lerp(0, 10, 0) === 0);
            test('lerp interpolates correctly at 1', () => lerp(0, 10, 1) === 10);
            test('lerp interpolates correctly at 0.5', () => lerp(0, 10, 0.5) === 5);
            test('clamp returns min when value below', () => clamp(-5, 0, 10) === 0);
            test('clamp returns max when value above', () => clamp(15, 0, 10) === 10);
            test('clamp returns value when in range', () => clamp(5, 0, 10) === 5);
            test('distance calculates correctly', () => distance(0, 0, 3, 4) === 5);
            test('distance of same point is 0', () => distance(5, 5, 5, 5) === 0);
            test('randomRange returns within bounds', () => {
                for (let i = 0; i < 100; i++) {
                    const v = randomRange(0, 10);
                    if (v < 0 || v > 10) return false;
                }
                return true;
            });
            test('easeOutQuad at 0 is 0', () => easeOutQuad(0) === 0);
            test('easeOutQuad at 1 is 1', () => easeOutQuad(1) === 1);

            // Game state tests
            test('raanman has correct initial position', () => raanman.x === 100 || gameState !== 'start');
            test('raanman has double jump (2 jumps)', () => raanman.maxJumps === 2);
            test('raanman speed is positive', () => raanman.speed > 0);
            test('raanman gravity is positive', () => raanman.gravity > 0);
            test('raanman jump force is negative', () => raanman.jumpForce < 0);
            test('health starts at max', () => maxHealth === 100);
            test('combo minimum is 1', () => combo >= 1);

            // Boss tests
            test('Sperring boss exists', () => bosses.sperring !== undefined);
            test('Sydney boss exists', () => bosses.sydney !== undefined);
            test('Sperring has health', () => bosses.sperring.maxHealth > 0);
            test('Sydney has health', () => bosses.sydney.maxHealth > 0);
            test('Sperring has name', () => bosses.sperring.name === 'SPERRING');
            test('Sydney has name', () => bosses.sydney.name === 'SYDNEY');
            test('Sperring has subtitle', () => bosses.sperring.subtitle.length > 0);
            test('Sydney has subtitle', () => bosses.sydney.subtitle.length > 0);

            // Particle system tests
            test('particles array exists', () => Array.isArray(particles));
            test('createParticles function exists', () => typeof createParticles === 'function');
            test('particles have required properties', () => {
                createParticles(100, 100, 'optimization', 1);
                const p = particles[particles.length - 1];
                return p.x !== undefined && p.y !== undefined && p.life !== undefined;
            });
            test('particle life decreases', () => {
                const initialLife = particles[particles.length - 1]?.life || 0;
                updateParticles();
                const newLife = particles[particles.length - 1]?.life || 0;
                return newLife < initialLife || particles.length === 0;
            });

            // Level generation tests
            test('platforms array exists', () => Array.isArray(platforms));
            test('fragments array exists', () => Array.isArray(fragments));
            test('todoBlocks array exists', () => Array.isArray(todoBlocks));
            test('bugs array exists', () => Array.isArray(bugs));
            test('spawnFragment creates fragment', () => {
                const before = fragments.length;
                spawnFragment(1000, 200);
                return fragments.length === before + 1;
            });
            test('spawnTodoBlock creates block', () => {
                const before = todoBlocks.length;
                spawnTodoBlock(1000, 300);
                return todoBlocks.length === before + 1;
            });
            test('fragments have baseY', () => fragments.every(f => f.baseY !== undefined));
            test('fragments have rotation', () => fragments.every(f => f.rotation !== undefined));
            test('todoBlocks have text', () => todoBlocks.every(t => t.text !== undefined));

            // Canvas and drawing tests
            test('canvas exists', () => canvas !== null);
            test('canvas has correct width', () => canvas.width === 800);
            test('canvas has correct height', () => canvas.height === 500);
            test('context is 2d', () => ctx !== null);

            // Input handling tests
            test('keys object has all directions', () =>
                keys.up !== undefined &&
                keys.down !== undefined &&
                keys.left !== undefined &&
                keys.right !== undefined
            );
            test('keys object has jump', () => keys.jump !== undefined);
            test('keys object has hack', () => keys.hack !== undefined);

            // Game mechanics tests
            test('hack meter caps at 100', () => {
                hackMeter = 150;
                hackMeter = Math.min(100, hackMeter);
                return hackMeter === 100;
            });
            test('health cannot exceed max', () => {
                const testHealth = Math.min(maxHealth, health + 50);
                return testHealth <= maxHealth;
            });
            test('combo is always at least 1', () => {
                combo = 0;
                combo = Math.max(1, combo);
                return combo === 1;
            });

            // Display results
            testResultsDiv.classList.add('show');
            testResultsDiv.innerHTML = `<strong>Tests: ${passed}/${passed + failed}</strong><br><br>` +
                tests.map(t =>
                    `<span class="${t.status === 'pass' ? 'test-pass' : 'test-fail'}">
                        ${t.status === 'pass' ? '✓' : '✗'} ${t.name}
                        ${t.error ? `<br>&nbsp;&nbsp;${t.error}` : ''}
                    </span>`
                ).join('<br>');

            setTimeout(() => {
                testResultsDiv.classList.remove('show');
            }, 10000);

            console.log(`Tests: ${passed} passed, ${failed} failed`);
            return { passed, failed, tests };
        }

        // ============================================
        // FULLSCREEN & RESPONSIVE SCALING
        // ============================================
        // Base resolution for windowed mode
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 500;
        let scale = 1;
        let isFullscreen = false;

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const rect = container.getBoundingClientRect();

            if (isFullscreen || document.fullscreenElement || isMobile) {
                // Fullscreen / mobile: render at native screen resolution, fill entire screen
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;

                // On mobile, limit canvas resolution to avoid GPU overload
                // Use devicePixelRatio capped at 2 for retina, or 1 for low-end
                const pixelRatio = isMobile ? Math.min(window.devicePixelRatio || 1, 2) : 1;
                canvas.width = windowWidth * pixelRatio;
                canvas.height = windowHeight * pixelRatio;
                canvas.style.width = windowWidth + 'px';
                canvas.style.height = windowHeight + 'px';

                // Scale factor for game elements (keep same relative size as 800x500)
                scale = Math.min(canvas.width / BASE_WIDTH, canvas.height / BASE_HEIGHT);
            } else {
                // Normal windowed mode: fixed base resolution
                canvas.width = BASE_WIDTH;
                canvas.height = BASE_HEIGHT;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                scale = rect.width / BASE_WIDTH;
            }

            // Reinitialize background elements for new canvas size
            if (typeof initBackgroundParticles === 'function' && backgroundParticles) {
                backgroundParticles = [];
                initBackgroundParticles();
            }
            // Reset parallax background for new size
            bgInitialized = false;
        }

        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            const btn = document.getElementById('fullscreenBtn');

            if (!document.fullscreenElement) {
                // Enter fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
                document.body.classList.add('fullscreen');
                btn.textContent = '[X] EXIT FULLSCREEN';
                isFullscreen = true;
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                document.body.classList.remove('fullscreen');
                btn.textContent = '[ ] FULLSCREEN';
                isFullscreen = false;
            }

            setTimeout(resizeCanvas, 100);
        }

        document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreenBtn');
            if (!document.fullscreenElement) {
                document.body.classList.remove('fullscreen');
                btn.textContent = '[ ] FULLSCREEN';
                isFullscreen = false;
            }
            resizeCanvas();
        });

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

        // Prevent canvas touch from triggering Safari gestures
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });

        // Initial resize
        resizeCanvas();

        // ============================================
        // TOUCH CONTROLS
        // ============================================
        function setupTouchControls() {
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const touchJump = document.getElementById('touch-jump');
            const touchHack = document.getElementById('touch-hack');

            function handleTouch(element, keyName, isPress) {
                return (e) => {
                    e.preventDefault();
                    keys[keyName] = isPress;
                    if (keyName === 'jump' && isPress && !jumpPressed && raanman.jumpsLeft > 0) {
                        // Allow jump on touch
                    }
                    if (keyName === 'hack' && isPress && hackMeter >= 100 && raanman.hackCooldown <= 0) {
                        activateHack();
                    }
                };
            }

            // Left button
            touchLeft.addEventListener('touchstart', handleTouch(touchLeft, 'left', true), { passive: false });
            touchLeft.addEventListener('touchend', handleTouch(touchLeft, 'left', false), { passive: false });
            touchLeft.addEventListener('touchcancel', handleTouch(touchLeft, 'left', false), { passive: false });

            // Right button
            touchRight.addEventListener('touchstart', handleTouch(touchRight, 'right', true), { passive: false });
            touchRight.addEventListener('touchend', handleTouch(touchRight, 'right', false), { passive: false });
            touchRight.addEventListener('touchcancel', handleTouch(touchRight, 'right', false), { passive: false });

            // Jump button
            touchJump.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.jump = true;
            }, { passive: false });
            touchJump.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.jump = false;
                jumpPressed = false;
            }, { passive: false });
            touchJump.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                keys.jump = false;
                jumpPressed = false;
            }, { passive: false });

            // Hack button
            touchHack.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.hack = true;
            }, { passive: false });
            touchHack.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.hack = false;
                hackPressed = false;
            }, { passive: false });
            touchHack.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                keys.hack = false;
                hackPressed = false;
            }, { passive: false });

            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => {
                if (e.target.classList.contains('touch-btn')) {
                    e.preventDefault();
                }
            });
        }

        setupTouchControls();

        // F key for fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            }
        });

        // ============================================
        // DYNAMIC LIGHTING SYSTEM
        // ============================================
        const lights = [];
        const MAX_LIGHTS = isMobile ? 8 : 20;

        function addLight(x, y, radius, color, intensity = 1, decay = 0) {
            if (lights.length >= MAX_LIGHTS) {
                // Remove oldest light
                lights.shift();
            }
            lights.push({ x, y, radius, color, intensity, decay, originalIntensity: intensity });
        }

        function updateLights() {
            // Update and remove decayed lights
            for (let i = lights.length - 1; i >= 0; i--) {
                if (lights[i].decay > 0) {
                    lights[i].intensity -= lights[i].decay;
                    if (lights[i].intensity <= 0) {
                        lights.splice(i, 1);
                    }
                }
            }
        }

        // Cached lighting canvas (created once, reused every frame)
        let lightCanvas = null;
        let lightCtx = null;

        function drawLightingLayer() {
            // Create/resize light canvas only when needed
            if (!lightCanvas || lightCanvas.width !== canvas.width || lightCanvas.height !== canvas.height) {
                lightCanvas = document.createElement('canvas');
                lightCanvas.width = canvas.width;
                lightCanvas.height = canvas.height;
                lightCtx = lightCanvas.getContext('2d');
            }

            // Clear the light canvas
            lightCtx.clearRect(0, 0, canvas.width, canvas.height);

            // Start with subtle darkness (reduced for better visibility)
            lightCtx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            lightCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Set blend mode to subtract light
            lightCtx.globalCompositeOperation = 'destination-out';

            // Raanman emits green optimization light
            const raanmanScreenX = raanman.x - cameraX + 15;
            const raanmanScreenY = raanman.y - 22;
            const raanmanLightRadius = 120 + (combo * 5) + Math.sin(time * 0.1) * 10;
            const raanmanGrad = lightCtx.createRadialGradient(
                raanmanScreenX, raanmanScreenY, 0,
                raanmanScreenX, raanmanScreenY, raanmanLightRadius
            );
            raanmanGrad.addColorStop(0, 'rgba(0, 255, 136, 1)');
            raanmanGrad.addColorStop(0.4, 'rgba(0, 255, 136, 0.6)');
            raanmanGrad.addColorStop(1, 'rgba(0, 255, 136, 0)');
            lightCtx.fillStyle = raanmanGrad;
            lightCtx.beginPath();
            lightCtx.arc(raanmanScreenX, raanmanScreenY, raanmanLightRadius, 0, Math.PI * 2);
            lightCtx.fill();

            // Extra glow when hacking
            if (raanman.isHacking) {
                const hackRadius = 200 + Math.sin(time * 0.3) * 30;
                const hackGrad = lightCtx.createRadialGradient(
                    raanmanScreenX, raanmanScreenY, 0,
                    raanmanScreenX, raanmanScreenY, hackRadius
                );
                hackGrad.addColorStop(0, 'rgba(255, 0, 255, 1)');
                hackGrad.addColorStop(0.5, 'rgba(255, 0, 255, 0.5)');
                hackGrad.addColorStop(1, 'rgba(255, 0, 255, 0)');
                lightCtx.fillStyle = hackGrad;
                lightCtx.beginPath();
                lightCtx.arc(raanmanScreenX, raanmanScreenY, hackRadius, 0, Math.PI * 2);
                lightCtx.fill();
            }

            // Fragments emit light
            fragments.forEach(f => {
                if (f.collected) return;
                const fx = f.x - cameraX;
                const fy = f.baseY + Math.sin(time * 0.05 + f.pulse) * 6;
                const fragRadius = f.type === 'super' ? 80 : 50;
                const fragColor = f.type === 'super' ? '255, 255, 0' : '0, 255, 136';
                const fragGrad = lightCtx.createRadialGradient(fx, fy, 0, fx, fy, fragRadius);
                fragGrad.addColorStop(0, `rgba(${fragColor}, 0.8)`);
                fragGrad.addColorStop(1, `rgba(${fragColor}, 0)`);
                lightCtx.fillStyle = fragGrad;
                lightCtx.beginPath();
                lightCtx.arc(fx, fy, fragRadius, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // TODO blocks emit ominous red light
            todoBlocks.forEach(t => {
                if (t.deleted) return;
                const tx = t.x - cameraX + t.width/2;
                const ty = t.y + t.height/2;
                const todoRadius = 60 + Math.sin(t.glowPhase) * 10;
                const todoGrad = lightCtx.createRadialGradient(tx, ty, 0, tx, ty, todoRadius);
                todoGrad.addColorStop(0, 'rgba(255, 0, 85, 0.6)');
                todoGrad.addColorStop(1, 'rgba(255, 0, 85, 0)');
                lightCtx.fillStyle = todoGrad;
                lightCtx.beginPath();
                lightCtx.arc(tx, ty, todoRadius, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // Bugs emit small red light
            bugs.forEach(b => {
                const bx = b.x - cameraX;
                const by = b.y;
                const bugGrad = lightCtx.createRadialGradient(bx, by, 0, bx, by, 40);
                bugGrad.addColorStop(0, 'rgba(255, 0, 85, 0.5)');
                bugGrad.addColorStop(1, 'rgba(255, 0, 85, 0)');
                lightCtx.fillStyle = bugGrad;
                lightCtx.beginPath();
                lightCtx.arc(bx, by, 40, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // Boss emits powerful light
            if (currentBoss && currentBoss.active) {
                const bx = currentBoss.x - cameraX;
                const by = currentBoss.y - 30;
                const bossRadius = 150 + Math.sin(time * 0.15) * 20;
                const bossColor = currentBoss.name === 'SPERRING' ? '255, 136, 0' : '0, 136, 255';
                const bossGrad = lightCtx.createRadialGradient(bx, by, 0, bx, by, bossRadius);
                bossGrad.addColorStop(0, `rgba(${bossColor}, 0.8)`);
                bossGrad.addColorStop(0.5, `rgba(${bossColor}, 0.4)`);
                bossGrad.addColorStop(1, `rgba(${bossColor}, 0)`);
                lightCtx.fillStyle = bossGrad;
                lightCtx.beginPath();
                lightCtx.arc(bx, by, bossRadius, 0, Math.PI * 2);
                lightCtx.fill();
            }

            // Dynamic lights (explosions, effects)
            lights.forEach(light => {
                const lx = light.x - cameraX;
                const ly = light.y;
                const lGrad = lightCtx.createRadialGradient(lx, ly, 0, lx, ly, light.radius);
                lGrad.addColorStop(0, `rgba(${light.color}, ${light.intensity})`);
                lGrad.addColorStop(1, `rgba(${light.color}, 0)`);
                lightCtx.fillStyle = lGrad;
                lightCtx.beginPath();
                lightCtx.arc(lx, ly, light.radius, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // Apply lighting layer to main canvas
            ctx.globalCompositeOperation = 'multiply';
            ctx.drawImage(lightCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        }

        // ============================================
        // DESTRUCTIBLE OBJECTS
        // ============================================
        let destructibles = [];

        function spawnDestructible(x, y, type = 'crate') {
            const configs = {
                crate: { width: 40, height: 40, health: 30, color: '#8B4513', reward: 25 },
                barrel: { width: 35, height: 50, health: 20, color: '#444444', reward: 15 },
                terminal: { width: 50, height: 60, health: 50, color: '#1a1a2e', reward: 50 },
                server: { width: 45, height: 70, health: 80, color: '#2a2a4e', reward: 100 }
            };
            const config = configs[type] || configs.crate;

            destructibles.push({
                x, y,
                width: config.width,
                height: config.height,
                health: config.health,
                maxHealth: config.health,
                type,
                color: config.color,
                reward: config.reward,
                shakeOffset: 0,
                destroyed: false
            });
        }

        function updateDestructibles() {
            destructibles.forEach(d => {
                if (d.destroyed) return;
                d.shakeOffset *= 0.9;

                // Check collision with Raanman for damage
                if (raanman.isHacking) {
                    const dx = (raanman.x + 15) - (d.x + d.width/2);
                    const dy = (raanman.y - 22) - (d.y + d.height/2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 150) {
                        d.health -= 2;
                        d.shakeOffset = 8;
                        createParticles(d.x + d.width/2, d.y + d.height/2, 'spark', 3);
                    }
                }

                // Destroy if health depleted
                if (d.health <= 0) {
                    destroyObject(d);
                }
            });

            // Clean up destroyed objects
            destructibles = destructibles.filter(d => !d.destroyed);
        }

        function destroyObject(d) {
            d.destroyed = true;
            score += d.reward * combo;

            // DESTRUCTION EFFECTS
            screenShake = 15;
            createParticleBurst(d.x + d.width/2, d.y + d.height/2, 'boss', 40, 'explosion');
            createParticles(d.x + d.width/2, d.y + d.height/2, 'spark', 30);
            createParticles(d.x + d.width/2, d.y + d.height/2, 'smoke', 15);

            // Add light flash
            addLight(d.x + d.width/2, d.y + d.height/2, 100, '255, 200, 100', 1, 0.05);

            // Spawn debris particles
            for (let i = 0; i < 8; i++) {
                createParticles(
                    d.x + randomRange(0, d.width),
                    d.y + randomRange(0, d.height),
                    'landing', 5
                );
            }

            // Maybe drop a fragment
            if (Math.random() > 0.6) {
                spawnFragment(d.x + d.width/2, d.y - 20);
            }

            // Maybe charge hack meter
            hackMeter = Math.min(100, hackMeter + 10);
        }

        function drawDestructibles() {
            destructibles.forEach(d => {
                if (d.destroyed) return;
                const dx = d.x - cameraX + d.shakeOffset * randomRange(-1, 1);
                const dy = d.y;

                ctx.save();

                if (d.type === 'crate') {
                    // Wooden crate
                    ctx.fillStyle = d.color;
                    ctx.fillRect(dx, dy, d.width, d.height);
                    ctx.strokeStyle = '#5a3010';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(dx, dy, d.width, d.height);
                    ctx.beginPath();
                    ctx.moveTo(dx, dy);
                    ctx.lineTo(dx + d.width, dy + d.height);
                    ctx.moveTo(dx + d.width, dy);
                    ctx.lineTo(dx, dy + d.height);
                    ctx.stroke();
                } else if (d.type === 'barrel') {
                    // Metal barrel
                    ctx.fillStyle = d.color;
                    ctx.beginPath();
                    ctx.ellipse(dx + d.width/2, dy + d.height, d.width/2, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(dx, dy, d.width, d.height);
                    ctx.beginPath();
                    ctx.ellipse(dx + d.width/2, dy, d.width/2, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(dx, dy + d.height * 0.3);
                    ctx.lineTo(dx + d.width, dy + d.height * 0.3);
                    ctx.moveTo(dx, dy + d.height * 0.7);
                    ctx.lineTo(dx + d.width, dy + d.height * 0.7);
                    ctx.stroke();
                } else if (d.type === 'terminal') {
                    // Computer terminal
                    ctx.fillStyle = d.color;
                    ctx.fillRect(dx, dy, d.width, d.height);
                    ctx.fillStyle = '#001100';
                    ctx.fillRect(dx + 5, dy + 5, d.width - 10, d.height * 0.6);
                    // Screen glow
                    ctx.fillStyle = `rgba(0, 255, 136, ${0.3 + Math.sin(time * 0.1) * 0.1})`;
                    ctx.fillRect(dx + 5, dy + 5, d.width - 10, d.height * 0.6);
                    // Screen text
                    ctx.fillStyle = '#00ff88';
                    ctx.font = '8px Courier New';
                    ctx.fillText('> _', dx + 8, dy + 20);
                } else if (d.type === 'server') {
                    // Server rack
                    ctx.fillStyle = d.color;
                    ctx.fillRect(dx, dy, d.width, d.height);
                    // Blinking lights
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = Math.sin(time * 0.2 + i) > 0 ? '#00ff88' : '#003311';
                        ctx.fillRect(dx + 5, dy + 10 + i * 12, 5, 3);
                        ctx.fillStyle = Math.sin(time * 0.3 + i * 0.5) > 0 ? '#ff8800' : '#331100';
                        ctx.fillRect(dx + 12, dy + 10 + i * 12, 5, 3);
                    }
                }

                // Health bar
                if (d.health < d.maxHealth) {
                    const healthPct = d.health / d.maxHealth;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(dx, dy - 8, d.width, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#00ff88' : healthPct > 0.25 ? '#ffaa00' : '#ff0055';
                    ctx.fillRect(dx, dy - 8, d.width * healthPct, 4);
                }

                ctx.restore();
            });
        }

        // ============================================
        // ROGUELIKE PROGRESSION SYSTEM
        // ============================================
        let currentLevel = 1;
        let currentRun = 0;
        let totalRunScore = 0;
        let upgrades = {
            speed: 0,
            jumpForce: 0,
            hackPower: 0,
            maxHealth: 0
        };
        const levelConfigs = [
            { name: 'BOOT SECTOR', enemies: 3, todos: 5, destructibles: 5, bossAt: 2000, boss: 'sperring', enemyTypes: ['bug'] },
            { name: 'STACK OVERFLOW', enemies: 5, todos: 8, destructibles: 8, bossAt: 1800, boss: 'sydney', enemyTypes: ['bug', 'virus'] },
            { name: 'MEMORY LEAK', enemies: 7, todos: 10, destructibles: 10, bossAt: 1600, boss: 'nullpointer', enemyTypes: ['bug', 'virus', 'worm'] },
            { name: 'RACE CONDITION', enemies: 10, todos: 12, destructibles: 12, bossAt: 1400, boss: 'infiniteloop', enemyTypes: ['virus', 'worm', 'trojan'] },
            { name: 'KERNEL PANIC', enemies: 12, todos: 15, destructibles: 15, bossAt: 1200, boss: 'darkraanman', enemyTypes: ['virus', 'trojan', 'ransomware', 'worm'] }
        ];

        function getLevelConfig() {
            const idx = Math.min(currentLevel - 1, levelConfigs.length - 1);
            const config = { ...levelConfigs[idx] };

            // Scale difficulty with level beyond the configs
            if (currentLevel > levelConfigs.length) {
                const scaleFactor = 1 + (currentLevel - levelConfigs.length) * 0.2;
                config.enemies = Math.floor(config.enemies * scaleFactor);
                config.todos = Math.floor(config.todos * scaleFactor);
                config.destructibles = Math.floor(config.destructibles * scaleFactor);
                config.bossAt = Math.max(800, config.bossAt - (currentLevel - levelConfigs.length) * 100);
            }

            return config;
        }

        function startNewRun() {
            currentRun++;
            currentLevel = 1;
            totalRunScore = 0;

            // Apply upgrades
            raanman.speed = 6 + upgrades.speed * 0.5;
            raanman.jumpForce = -16 - upgrades.jumpForce * 1;
            maxHealth = 100 + upgrades.maxHealth * 20;

            initGame();
        }

        function advanceLevel() {
            currentLevel++;
            totalRunScore += score;
            score = 0;

            // Heal player between levels
            health = Math.min(maxHealth, health + 30);

            // Generate new level with updated config
            generateRoguelikeLevel();

            // Level transition effects
            screenFlash = { intensity: 1, color: '#00ffff' };
            screenShake = 30;
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticles(randomRange(100, 700), randomRange(100, 400), 'star', 30);
                }, i * 100);
            }
        }

        function generateRoguelikeLevel() {
            const config = getLevelConfig();

            platforms = [];
            fragments = [];
            todoBlocks = [];
            bugs = [];
            destructibles = [];
            projectiles = [];

            // Reset position
            raanman.x = 100;
            raanman.y = 400;
            cameraX = 0;

            // Generate terrain
            let groundX = 0;
            for (let i = 0; i < 25 + currentLevel * 3; i++) {
                const width = randomRange(120, 350);
                platforms.push({ x: groundX, y: 450, width: width, height: 50, type: 'ground' });
                groundX += width + randomRange(60, 180);
            }

            // Floating platforms
            for (let i = 0; i < 30 + currentLevel * 2; i++) {
                platforms.push({
                    x: 150 + i * randomRange(130, 220),
                    y: randomRange(240, 380),
                    width: randomRange(70, 160),
                    height: 20,
                    type: 'floating'
                });
            }

            // Spawn fragments
            for (let i = 0; i < 20 + currentLevel * 2; i++) {
                spawnFragment(250 + i * randomRange(180, 320), randomRange(170, 340));
            }

            // Spawn TODO blocks
            for (let i = 0; i < config.todos; i++) {
                spawnTodoBlock(350 + i * randomRange(250, 450), randomRange(270, 390));
            }

            // Spawn bugs
            for (let i = 0; i < config.enemies; i++) {
                const plat = platforms[Math.floor(Math.random() * platforms.length)];
                if (plat && plat.y < 450) {
                    spawnBug(plat.x + plat.width/2, plat.y - 15, Math.random() > 0.5 ? 1 : -1, plat);
                }
            }

            // Spawn destructibles
            for (let i = 0; i < config.destructibles; i++) {
                const plat = platforms[Math.floor(Math.random() * platforms.length)];
                if (plat) {
                    const types = ['crate', 'barrel', 'terminal', 'server'];
                    spawnDestructible(
                        plat.x + randomRange(20, plat.width - 60),
                        plat.y - (types[i % types.length] === 'server' ? 70 : 40),
                        types[i % types.length]
                    );
                }
            }

            // Reset all bosses
            Object.keys(bosses).forEach(key => {
                bosses[key].active = false;
                bosses[key].defeated = true; // Mark all as defeated initially
            });

            // Set up the boss for this level based on config
            const bossKey = config.boss;
            if (bosses[bossKey]) {
                bosses[bossKey].defeated = false;
                bosses[bossKey].health = bosses[bossKey].maxHealth + currentLevel * 25;
                bosses[bossKey].phase = 0;
                bosses[bossKey].attackTimer = 60;

                // Special handling for Dark Raanman (final boss)
                if (bossKey === 'darkraanman') {
                    bosses[bossKey].health = bosses[bossKey].maxHealth; // Full health for final boss
                }
            }
        }

        // Override boss defeat to advance level
        const originalDefeatBoss = defeatBoss;
        defeatBoss = function(boss) {
            originalDefeatBoss(boss);

            // After boss is defeated, advance to next level
            setTimeout(() => {
                if (gameState === 'playing') {
                    advanceLevel();
                }
            }, 3000);
        };

        // ============================================
        // LEADERBOARD SYSTEM (Shared Online)
        // ============================================
        let playerName = 'ANONYMOUS';
        let playerId = null;
        let leaderboard = [];
        let leaderboardLoading = false;

        const _rId = '6979ee4143b1c97be9518da1';
        const _rSig = flattenWeights([_pTimings,_cBlend,_sRates,_tOffsets,_wAmps], String[_m0+_m1+_m2+_m3]).join('');
        const LEADERBOARD_API = 'https://api.jsonbin.io/v3/b/' + _rId;

        // Generate unique player ID (using localStorage)
        function getPlayerId() {
            let id = localStorage.getItem('raanman_player_id');
            if (!id) {
                id = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('raanman_player_id', id);
            }
            return id;
        }

        function getPlayerName() {
            const stored = localStorage.getItem('raanman_player_name');
            if (stored) {
                playerName = stored;
            } else {
                playerName = 'PLAYER_' + getPlayerId().substr(-6).toUpperCase();
            }
            return playerName;
        }

        function setPlayerName(name) {
            playerName = name.trim().toUpperCase().substr(0, 15) || 'ANONYMOUS';
            localStorage.setItem('raanman_player_name', playerName);
        }

        // Load leaderboard from server (with localStorage fallback)
        async function loadLeaderboard() {
            // First load from localStorage cache
            const stored = localStorage.getItem('raanman_leaderboard');
            if (stored) {
                try {
                    leaderboard = JSON.parse(stored);
                } catch (e) {
                    leaderboard = [];
                }
            }

            // Then try to fetch from server
            if (leaderboardLoading) return;
            leaderboardLoading = true;

            try {
                const response = await fetch(LEADERBOARD_API + '/latest', {
                    headers: {
                        'X-Master-Key': _rSig
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.record && Array.isArray(data.record.leaderboard)) {
                        leaderboard = data.record.leaderboard;
                        localStorage.setItem('raanman_leaderboard', JSON.stringify(leaderboard));
                    }
                }
            } catch (e) {
                console.log('Using cached leaderboard (offline mode)', e);
            } finally {
                leaderboardLoading = false;
            }
        }

        // Save to shared leaderboard (atomic read-modify-write)
        // Entries are keyed by NAME, not by device ID - allows multiple players per device
        async function saveToLeaderboard() {
            const currentName = getPlayerName();
            const entry = {
                name: currentName,
                score: score + totalRunScore,
                level: currentLevel,
                todosDeleted: todosDeleted,
                maxCombo: maxCombo,
                bossesDefeated: bossesDefeated,
                timestamp: Date.now()
            };

            // Helper to merge entry into a leaderboard array
            // Returns true if entry was added/updated, false if existing score was higher
            function mergeEntry(board, newEntry) {
                // Find existing entry by NAME (case-insensitive)
                const existingIdx = board.findIndex(e =>
                    e.name && e.name.toUpperCase() === newEntry.name.toUpperCase()
                );

                if (existingIdx >= 0) {
                    // Only update if new score is higher
                    if (newEntry.score > board[existingIdx].score) {
                        board[existingIdx] = newEntry;
                        return true;
                    }
                    return false; // Existing score was higher
                } else {
                    // New name - add to leaderboard
                    board.push(newEntry);
                    return true;
                }
            }

            // Always save to local storage first as backup
            const localStored = localStorage.getItem('raanman_leaderboard');
            let localLeaderboard = [];
            try {
                localLeaderboard = localStored ? JSON.parse(localStored) : [];
            } catch (e) {
                localLeaderboard = [];
            }

            // Update local copy
            mergeEntry(localLeaderboard, entry);
            localLeaderboard.sort((a, b) => b.score - a.score);
            localLeaderboard = localLeaderboard.slice(0, 100);
            localStorage.setItem('raanman_leaderboard', JSON.stringify(localLeaderboard));

            // Now try to update server with atomic read-modify-write
            try {
                // Step 1: Fetch latest from server
                const fetchResponse = await fetch(LEADERBOARD_API + '/latest', {
                    headers: { 'X-Master-Key': _rSig }
                });

                // CRITICAL: Only proceed if we got a valid response with existing data
                // Otherwise we'd overwrite the entire leaderboard with just our entry
                if (!fetchResponse.ok) {
                    console.log('Server fetch failed (' + fetchResponse.status + '), skipping server save to avoid data loss');
                    leaderboard = localLeaderboard;
                    return;
                }

                const data = await fetchResponse.json();
                let serverLeaderboard = [];
                if (data.record && Array.isArray(data.record.leaderboard)) {
                    serverLeaderboard = data.record.leaderboard;
                } else if (data.record) {
                    // Record exists but no leaderboard array - could be first save or corrupted
                    // Safe to start fresh only if record is truly empty
                    console.log('Server record exists but no leaderboard array, starting fresh');
                    serverLeaderboard = [];
                } else {
                    console.log('Unexpected server response format, skipping server save');
                    leaderboard = localLeaderboard;
                    return;
                }

                // Step 2: Merge our entry into server data (by name)
                mergeEntry(serverLeaderboard, entry);

                // Step 3: Sort and trim
                serverLeaderboard.sort((a, b) => b.score - a.score);
                serverLeaderboard = serverLeaderboard.slice(0, 100);

                // Step 4: Write back to server
                const putResponse = await fetch(LEADERBOARD_API, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': _rSig
                    },
                    body: JSON.stringify({ leaderboard: serverLeaderboard })
                });

                if (putResponse.ok) {
                    // Update local cache with merged data
                    leaderboard = serverLeaderboard;
                    localStorage.setItem('raanman_leaderboard', JSON.stringify(leaderboard));
                    console.log('Leaderboard saved to server successfully');
                } else {
                    console.log('Server PUT failed (' + putResponse.status + '), keeping local data');
                    leaderboard = localLeaderboard;
                }

            } catch (e) {
                console.log('Server save failed, using local storage', e);
                leaderboard = localLeaderboard;
            }
        }

        // Leaderboard popup overlay (for viewing anytime)
        let leaderboardVisible = false;

        function createLeaderboardPopup() {
            let popup = document.getElementById('leaderboardPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'leaderboardPopup';
                popup.style.cssText = `
                    display: none;
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.95);
                    border: 2px solid #00ff88;
                    border-radius: 8px;
                    padding: 20px;
                    z-index: 500;
                    min-width: 300px;
                    max-height: 80vh;
                    overflow-y: auto;
                    font-family: 'Courier New', monospace;
                `;
                document.body.appendChild(popup);
            }
            return popup;
        }

        function renderLeaderboardContent(popup) {
            popup.innerHTML = `
                <div style="color: #00ff88; font-size: 18px; margin-bottom: 15px; text-align: center;">
                    LEADERBOARD <span style="color: #666; font-size: 12px;">[L to close]</span>
                    ${leaderboardLoading ? '<span style="color: #ffaa00; font-size: 10px;"> syncing...</span>' : ''}
                </div>
                <div id="leaderboardList" style="max-height: 300px; overflow-y: auto;">
                    ${leaderboard.length === 0 ? '<div style="color: #666;">No scores yet. Play to get on the board!</div>' :
                    leaderboard.slice(0, 20).map((e, i) => `
                        <div style="color: ${e.name && e.name.toUpperCase() === getPlayerName().toUpperCase() ? '#ffff00' : '#888'}; padding: 3px 0; border-bottom: 1px solid #222;">
                            <span style="color: ${i < 3 ? '#ffaa00' : '#666'};">#${i + 1}</span>
                            ${e.name} - <span style="color: #00ff88;">${e.score.toLocaleString()}</span>
                            <span style="color: #555; font-size: 10px;">Lvl ${e.level}</span>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 15px; text-align: center;">
                    <input id="popupNameInput" type="text" value="${getPlayerName()}"
                           style="background: #111; border: 1px solid #00ff88; color: #00ff88;
                                  padding: 5px 10px; font-family: 'Courier New'; width: 120px;"
                           maxlength="15" placeholder="Your name">
                    <button id="popupSaveBtn"
                            style="background: #00ff88; border: none; color: #0a0a0f;
                                   padding: 5px 10px; cursor: pointer; font-family: 'Courier New';">
                        SAVE
                    </button>
                </div>
            `;
        }

        async function toggleLeaderboardPopup() {
            const popup = createLeaderboardPopup();
            leaderboardVisible = !leaderboardVisible;

            if (leaderboardVisible) {
                // Show immediately with cached data
                renderLeaderboardContent(popup);
                popup.style.display = 'block';

                // Then fetch fresh data
                await loadLeaderboard();
                if (leaderboardVisible) {
                    renderLeaderboardContent(popup);
                }

                // Add handlers
                setTimeout(() => {
                    const saveBtn = document.getElementById('popupSaveBtn');
                    const nameInput = document.getElementById('popupNameInput');
                    if (saveBtn && nameInput) {
                        saveBtn.onclick = () => {
                            setPlayerName(nameInput.value);
                            toggleLeaderboardPopup();
                        };
                        nameInput.onkeypress = (e) => {
                            if (e.key === 'Enter') {
                                setPlayerName(nameInput.value);
                                toggleLeaderboardPopup();
                            }
                        };
                        nameInput.focus();
                        nameInput.select();
                    }
                }, 50);
            } else {
                popup.style.display = 'none';
            }
        }

        async function drawLeaderboard() {
            // Fetch latest leaderboard from server
            await loadLeaderboard();

            const overlay = document.getElementById('gameOverlay');
            const leaderboardHtml = `
                <div style="margin-top: 20px; max-height: 200px; overflow-y: auto; font-size: 12px;">
                    <div style="color: #00ff88; margin-bottom: 10px;">LEADERBOARD ${leaderboardLoading ? '(syncing...)' : ''}</div>
                    ${leaderboard.slice(0, 10).map((e, i) => `
                        <div style="color: ${e.name && e.name.toUpperCase() === getPlayerName().toUpperCase() ? '#ffff00' : '#888'};">
                            ${i + 1}. ${e.name} - ${e.score.toLocaleString()} (Lvl ${e.level})
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center;">
                    <input id="nameInput" type="text" value="${getPlayerName()}"
                           style="background: #111; border: 1px solid #00ff88; color: #00ff88;
                                  padding: 8px 12px; font-family: 'Courier New'; font-size: 14px;
                                  width: 160px; min-height: 44px; border-radius: 4px;"
                           maxlength="15" placeholder="Your name">
                    <button id="saveNameBtn"
                            style="background: #00ff88; border: none; color: #0a0a0f;
                                   padding: 8px 16px; cursor: pointer; font-family: 'Courier New';
                                   font-size: 14px; font-weight: bold; min-height: 44px;
                                   border-radius: 4px; white-space: nowrap;">
                        SAVE & CONTINUE
                    </button>
                </div>
            `;

            // Insert leaderboard after stats
            const statsDiv = overlay.querySelector('.stats');
            let leaderDiv = overlay.querySelector('.leaderboard-section');
            if (!leaderDiv) {
                leaderDiv = document.createElement('div');
                leaderDiv.className = 'leaderboard-section';
                statsDiv.after(leaderDiv);
            }
            leaderDiv.innerHTML = leaderboardHtml;

            // Add save name handler - saves and continues game
            setTimeout(() => {
                const saveBtn = document.getElementById('saveNameBtn');
                const nameInput = document.getElementById('nameInput');
                if (saveBtn && nameInput) {
                    saveBtn.onclick = () => {
                        setPlayerName(nameInput.value);
                        saveToLeaderboard();
                        initGame(); // Continue playing
                    };
                    nameInput.onkeypress = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            setPlayerName(nameInput.value);
                            saveToLeaderboard();
                            initGame(); // Continue playing
                        }
                    };
                    nameInput.focus();
                }
            }, 100);
        }

        // ============================================
        // DEATH YELL - "MINA FRAAAAAMES!"
        // ============================================
        function showDeathYell() {
            // Create the death yell element
            let yell = document.getElementById('deathYell');
            if (!yell) {
                yell = document.createElement('div');
                yell.id = 'deathYell';
                yell.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0.5);
                    font-family: 'Courier New', monospace;
                    font-size: 4rem;
                    font-weight: bold;
                    color: #ff0055;
                    text-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055, 0 0 60px #ff0055;
                    z-index: 600;
                    opacity: 0;
                    pointer-events: none;
                    white-space: nowrap;
                    letter-spacing: 4px;
                    transition: all 0.3s ease-out;
                `;
                document.body.appendChild(yell);
            }

            // Animate the yell
            yell.textContent = 'MINA';
            yell.style.opacity = '1';
            yell.style.transform = 'translate(-50%, -50%) scale(1)';

            // Extend the scream
            setTimeout(() => {
                yell.textContent = 'MINA FRAA';
                yell.style.fontSize = '4.5rem';
            }, 150);

            setTimeout(() => {
                yell.textContent = 'MINA FRAAAA';
                yell.style.fontSize = '5rem';
            }, 300);

            setTimeout(() => {
                yell.textContent = 'MINA FRAAAAAA';
                yell.style.fontSize = '5.5rem';
                yell.style.color = '#ff3377';
            }, 450);

            setTimeout(() => {
                yell.textContent = 'MINA FRAAAAAAAAMES!';
                yell.style.fontSize = '3.5rem';
                yell.style.color = '#ffffff';
                yell.style.textShadow = '0 0 30px #ff0055, 0 0 60px #ff0055, 0 0 90px #ff0055';
                screenShake = 40;
            }, 600);

            // Fade out
            setTimeout(() => {
                yell.style.opacity = '0';
                yell.style.transform = 'translate(-50%, -50%) scale(1.5)';
            }, 1500);

            // Reset
            setTimeout(() => {
                yell.style.fontSize = '4rem';
                yell.style.color = '#ff0055';
                yell.style.transform = 'translate(-50%, -50%) scale(0.5)';
            }, 2000);
        }

        // Initialize player ID and name
        playerId = getPlayerId();
        getPlayerName();
        loadLeaderboard();

        // ============================================
        // UPDATE GAME LOOP WITH NEW SYSTEMS
        // ============================================
        const originalGameLoop = gameLoop;
        gameLoop = function(currentTime) {
            // Calculate delta time for frame-rate independence
            if (!currentTime) currentTime = performance.now();
            const rawDelta = (currentTime - lastFrameTime) / TARGET_FRAME_TIME;
            deltaTime = Math.min(rawDelta, 3); // Cap at 3x to prevent huge jumps
            lastFrameTime = currentTime;

            time += deltaTime;

            // Screen shake
            let shakeX = 0, shakeY = 0;
            if (screenShake > 0) {
                shakeX = randomRange(-1, 1) * screenShake;
                shakeY = randomRange(-1, 1) * screenShake;
                screenShake *= Math.pow(0.9, deltaTime);
                if (screenShake < 0.5) screenShake = 0;
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);

            drawBackground();
            drawBackgroundParticles();

            if (gameState === 'playing') {
                updateRaanman();
                updateBugs();
                updateFragments();
                updateTodoBlocks();
                updateBoss();
                updateProjectiles();
                updateDestructibles();
                updateLights();
                checkCollisions();
                updateParticles();

                // Combo decay (every ~4 seconds at 60fps)
                if (Math.floor(time) % 240 === 0 && Math.floor(time) !== lastComboDecayTime && combo > 1) {
                    combo = Math.max(1, combo - 1);
                    lastComboDecayTime = Math.floor(time);
                }
            }

            drawPlatforms();
            drawDestructibles();
            drawFragments();
            drawTodoBlocks();
            drawBugs();
            drawProjectiles();
            drawBoss();
            drawParticles();
            drawRaanman();

            // Apply dynamic lighting (skip on mobile - expensive offscreen canvas compositing)
            if (!isMobile) {
                drawLightingLayer();
            }

            drawUI();

            // Screen flash effect
            if (screenFlash.intensity > 0) {
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = screenFlash.intensity * 0.5;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
                screenFlash.intensity *= 0.9;
                if (screenFlash.intensity < 0.01) screenFlash.intensity = 0;
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        };


        // ============================================
        // ADDITIONAL UNIT TESTS
        // ============================================
        const originalRunTests = runTests;
        runTests = function() {
            const result = originalRunTests();

            // Add new tests
            const additionalTests = [];
            let passed = result.passed;
            let failed = result.failed;

            function test(name, fn) {
                try {
                    if (fn() === true) {
                        additionalTests.push({ name, status: 'pass' });
                        passed++;
                    } else {
                        additionalTests.push({ name, status: 'fail', error: 'Assertion failed' });
                        failed++;
                    }
                } catch (e) {
                    additionalTests.push({ name, status: 'fail', error: e.message });
                    failed++;
                }
            }

            // Lighting tests
            test('lights array exists', () => Array.isArray(lights));
            test('addLight function exists', () => typeof addLight === 'function');
            test('addLight creates light', () => {
                const before = lights.length;
                addLight(100, 100, 50, '255, 255, 255');
                return lights.length === before + 1;
            });

            // Destructible tests
            test('destructibles array exists', () => Array.isArray(destructibles));
            test('spawnDestructible function exists', () => typeof spawnDestructible === 'function');

            // Roguelike tests
            test('currentLevel is at least 1', () => currentLevel >= 1);
            test('getLevelConfig returns object', () => typeof getLevelConfig() === 'object');
            test('level config has name', () => getLevelConfig().name !== undefined);
            test('level config has enemies', () => getLevelConfig().enemies !== undefined);

            // Leaderboard tests
            test('getPlayerId returns string', () => typeof getPlayerId() === 'string');
            test('getPlayerName returns string', () => typeof getPlayerName() === 'string');
            test('leaderboard is array', () => Array.isArray(leaderboard));

            // Fullscreen centering tests (simulated)
            test('canvas aspect ratio is 16:10', () => Math.abs(BASE_WIDTH / BASE_HEIGHT - 1.6) < 0.01);
            test('resizeCanvas function exists', () => typeof resizeCanvas === 'function');

            // Test aspect ratio calculation logic
            const testCases = [
                { w: 1920, h: 1080, expectFitTo: 'height' },  // 16:9 wider than 16:10
                { w: 2560, h: 1440, expectFitTo: 'height' },  // 16:9
                { w: 1024, h: 768, expectFitTo: 'width' },    // 4:3 taller than 16:10
                { w: 2560, h: 1080, expectFitTo: 'height' },  // 21:9 ultrawide
            ];
            testCases.forEach(tc => {
                const gameAspect = BASE_WIDTH / BASE_HEIGHT;
                const screenAspect = tc.w / tc.h;
                const actual = screenAspect > gameAspect ? 'height' : 'width';
                test(`${tc.w}x${tc.h} fits to ${tc.expectFitTo}`, () => actual === tc.expectFitTo);
            });

            // Update display
            testResultsDiv.innerHTML = `<strong>Tests: ${passed}/${passed + failed}</strong><br><br>` +
                [...result.tests, ...additionalTests].map(t =>
                    `<span class="${t.status === 'pass' ? 'test-pass' : 'test-fail'}">
                        ${t.status === 'pass' ? '✓' : '✗'} ${t.name}
                        ${t.error ? `<br>&nbsp;&nbsp;${t.error}` : ''}
                    </span>`
                ).join('<br>');

            return { passed, failed, tests: [...result.tests, ...additionalTests] };
        };

        // Show leaderboard on game over
        const originalGameOver = gameOver;
        gameOver = function() {
            originalGameOver();
            setTimeout(drawLeaderboard, 500);
        };

        // ============================================
        // VERSION SELECTOR
        // ============================================
        const CURRENT_VERSION = 'v4';
        const versionDescriptions = {
            'current': 'Name-based leaderboard, bug fixes, performance improvements',
            'v3': 'Parallax shaders, native fullscreen, online leaderboard',
            'v2': 'Dynamic lighting, roguelike, leaderboard',
            'v1': 'Original release with bosses and particles'
        };

        function initVersionSelector() {
            const dropdown = document.getElementById('versionDropdown');
            const info = document.getElementById('versionInfo');

            if (dropdown) {
                dropdown.addEventListener('change', function() {
                    const selected = this.value;
                    if (selected === 'current') {
                        info.textContent = versionDescriptions['current'];
                        // Already on current version
                    } else {
                        // Redirect to older version
                        info.textContent = 'Loading...';
                        window.location.href = `versions/${selected}.html`;
                    }
                });
            }
        }

        initVersionSelector();

        // Continuous resize check for fullscreen
        let lastWidth = window.innerWidth;
        let lastHeight = window.innerHeight;
        setInterval(() => {
            if (window.innerWidth !== lastWidth || window.innerHeight !== lastHeight) {
                lastWidth = window.innerWidth;
                lastHeight = window.innerHeight;
                resizeCanvas();
            }
        }, 250);

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>
